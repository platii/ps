#include <iostream>
using namespace std;

int n, d[12];

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin>>t;
    d[1]=1; //초기값 대입
    d[2]=2;
    d[3]=4;
    for(int i=4; i<=11; i++) d[i]=d[i-1]+d[i-2]+d[i-3]; //d배열을 미리 모두 채움.
    while(t--){
        cin>>n;
        cout<<d[n]<<'\n';
    }
}



/* 
# n이 충분히 작은 경우, 브루트포스나 백트래킹으로 풀 수도 있지만 n이 커지면 불가능함.

1. 테이블 구성
d[i]=>i를 1,2,3의 합으로 만들어내는 방법의 수

2. 점화식 설정
d[i]= d[i-1]+d[i-2]+d[i-3];

ex) d[4]
1 1 1 1, 1 2 1, 2 1 1, 3 1 (추가로 1을 더해야하는 경우) (d[i-1]개)
1 1 2, 2 2 (추가로 2를 더해야 하는 경우)(d[i-2]개)
1 3 (추가로 3을 더해야하는 경우)(d[i-3]개)


3. 초기값 대입
d[1]=1, d[2]=2, d[3]=4;

기존 작성 코드
->
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin>>t;
    d[1]=1; //초기값 대입
    d[2]=2;
    d[3]=4;
    while(t--){
        cin>>n;
        for(int i=4; i<=n; i++){
            d[i]=d[i-1]+d[i-2]+d[i-3];
        }
        cout<<d[n]<<'\n';
    }
}
//정답 코드는 매 테스트케이스마다 d를 새로 계산하지 않고 맨처음 n자리 까지의 d[i]를 먼저 다 계산해 두었음.
***dp 문제의 경우 테스트케이스를 여러개 실행해야 하는 경우
매 테스트 케이스마다 d[n]까지 구하는 건 비효율적
미리 제한 범위까지 계산을 해두자. 어짜피 이렇게 되면 시간복잡도는 o(n)을 넘지 않으므로 
시간제한이 1초(1억번연산)라고 하였을 때 대략 범위가 넉넉하게 4000만까지 주어지더라도 가능함.
(조건에 맞게 출력하는 것은 본 코드와 같이 작성하면 되므로 시간복잡도면에서 영향이 거의 미미)

*/