#include<iostream>
using namespace std;

int mod=10007;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin>>n;
    int d[10000];//테이블 정의
    d[1]=1; d[2]=2; //초기값대입
    for(int i=3; i<=n; i++){ //점화식 반복문
        // d[i]=(d[i-1]%10007+d[i-2]%10007)%10007; 수정 전 식
        d[i]=(d[i-1]+d[i-2])%mod; //답지의 식, (1)어짜피 mod로나눈 나머지가 저장되어있을테니 굳이 또 안나눠도됨. (2)mod를 하드코딩하지않고 미리 정의해둠.
    }                             //근데, 잘생각해보면 수정 전식이 잘못된건데, 어떻게 답이 맞았지? -> 이미 나머지라서, mod로 나눠도 동일했나봄
    cout<<d[n];
}



/*
dp의 구조
1) 테이블 정의하기
d[i] = 테이블이 2*i크기의 테이블일 때 2*1, 1*2블록으로 채울 수 있는 경우의 수

2) 점화식 찾기
d[i] = d[i-1]+d[i-2]

3) 초기값 대입
d[1]=1, d[2]=2;

(이게 기본 풀이흐름이고, 여기에 mod분배법칙 적용한게 본 코드)

(a+b)mod x =(a mod x +b mod x)mod x

https://alive-wong.tistory.com/59   <- 유도방법은 궁금하면 확인하는걸로.

풀이
d[1]=1
d[2]=2
d[3]=3
d[4]=5
d[5]=8
d[6]=13
->d[i]=d[i-1]+d[i-2]

각 d[i]는 
2*1블록(누워있는 블럭)두개를 쌓은 2*2블럭의 개수마다 경우의수를 셀 수있음.
누워있는 2*2블록이 0개일때, 1개일때, 2개일때 ... floor[i/2] 개일때

점화식이 이렇게 생기는 이유?

-> https://blog.encrypted.gg/974
여기서 확인했음.
이거 시간 2시간 더줘도 왜이렇게 되는지 몰랐을듯.

>>dp문제 풀때는 "초기 상태에서 분기점 체크" 접근법을 기억.


우선구현함.

>>>오류!!<<<<
-> 10007로 나누기전 d[i]에 저장되어있는 값이 int값이기 때문에
2의 31승을 넘기면 오버플로우 오류남.

mod의 분배법칙을 사용해야함.

mod의 분배법칙이란.
a, b, x가 임의 수 일 때
(a+b)mod x =(a mod x +b mod x)mod x가 되는 걸 말함.



////////////
[여담, mod의 분배법칙, 2024-1 이산수학 수업때 배웠던 내용이다. 쓸모없다고 생각한 내용이 여기서 이렇게 활용되다니,
역시, 학부 수준에서는 무엇이 중요하고 무엇이 실무에 쓰이는지 가늠하기가 어렵다. 그저 수업을 들을 뿐,
그렇다면, 모든 수업을 실무에 적용될 것이라고 생각하고 머리 속 깊숙히 암기해야하는가?
근데 그건 비용이 너무 많이든다. 뇌는 당연하게도 자주 쓰지않는 지식은 머리속에서 잊혀지게 만든다.
그러면 어짜피 깊게 공부-암기하더라도 쓰지않으면 잊혀진다.
언제 쓸지 모르는 지식을 그렇게 까지 암기하는건 낭비다.

그렇다면 어떻게 하는것이 좋은가?
모든 수업에서 그러하듯, 이런게 있다라는걸 기억해두는 정도면 충분한것이 아닌가.
지금 문제같은 경우도 mod의 분배법칙이 있다라는걸 알기에 
인터넷에 '(a+b)의 mod, mod의 덧셈법칙'같이 연상되는 단어를 검색해서 
결론적으로 mod의 분배법칙이 무엇인지를 찾아낼 수 있었다. (이 내용이 이산수학에서 배운내용이었고, 덧셈법칙~?같은건 없었다.)
그리고, 그것의 공식을 찾아 낼 수있었다. -> (a+b)mod x =(a mod x +b mod x)mod x

물론, 이 공식이 어떻게 유도되는지 까지도 본문에 나와있었지만,
벌써 반년이란 시간이 지나서(사실, 수업때, 유도부분은 주의깊게 보지않아서)
까먹었다. 다만, 수업때 주의깊게 들었다면 그리고 한번이상 직접 유도 해 보았다면, 본문의 유도과정을
읽는 것 만으로도 그 과정이 왜 그렇게 되었는지 이해할 수 있을 것이다.

'이런게 있었지'를 아는것과 모르는것의 차이를 시뮬레이션해보면,
'이런게 있었지'를 몰랐다면, 아마도 10007을 나누기 전의 수가 과도하게 커지면,
이를 어떻게 처리하지? 단순히 변수타입을 무한정 크게 정의하는 거 말고는 
다른 생각을 못했을 확률이높다.
그러면? 아마 답지를 봤을 확률이높다.
그리고, 답지를 보고 mod공식을 확인하게 될 것이다.

그러면 '이런게 있었지'를 알면, 문제를 보기전에 내 배경지식, mod공식을 활용할 수 있다.
모르면, 문제를 접하고 나서 mod공식을 배우게된다.
근데, 잘생각해보면,
전자는 문제를 보기전에 안거고,
후자는 문제를 보고나서 안건데,

사실 둘 의 차이는 단지 언제 알게되었냐의 차이고, 결국 그 개념을 배웠다는점에서 차이는별로 없는것같다.
오히려, 후자의 경우가,
공식이 실무에서 어떻게 적용되는지와 공식이 왜필요한지 '필요성'을 느끼고 나서 공식을 외우기때문에 더 좋은거아닌가?
왜 그렇게 전공지식을 그렇게나 처 배우게 시키는거지?
역시, 너무 많이배운다.

하지만,일단 뭘 할려면 기초는 알아야된다. 
예를들어 대부분의 경우에서, 자바의 기초도 모르고 웹개발을 시작할 순 없다. 
최소한, 문법이 어떻게 되는지, 클래스는 뭔지는 알아야 코드를 치지.

근데, 뭐 예를들어 웹 클래스의 무슨무슨함수? 이런거까지 처음부터 다 배울 필요는 없겠지.
이런건진짜로 이런게 있다정도만 알고넘어가면된다.
어짜피 나중에 알게될거니까.

그럼 진짜로, 초반(실무가 아닌 지식 습득 단계)엔 배워야하는건 그 내용의 깊은 지식이 아닐까?
실무때는 지식을 얉고, 넓게 습득하지 운영체제의 page table의 작동방식의 뭐 더깊은 지식같은걸
공부하긴 힘들 것이다.(그럴 필요도없고)

근데 또, 깊은 지식 같은 경우 실무를 안하면 이해가 힘든경우가 있다. 
혹은 실무를 뛰어봐야 훨씬 잘 이해되는경우가 있다.
그렇게 생각해보면
특히, 컴과같은 경우 우선 적당한 깊이로 기초를 배우고
본인의 필드에서 직접 실무를 뛰어 보면서 필요한 지식을 선취하여 깊게 학습하는게 제일 효율적인게 아닐까.

그럼 '우선 적당한 깊이'라는건 어느정도일까.
->이걸 처음 배우는 입장에서는 솔직히 알기어렵다. 그래서 이미 많이 배워본, 실무를 해본사람한테서 배우는거고.
->그래서 실무를 직접 해보고, 깊게 들어가는게 더 효율적인거고(그게 왜 쓰이는건지, 어떻게 쓰이는 지 필요성을 직접 볼 수 있으니까)
그래서, 일단은 가르치는데로 습득해보고 ,그다음에 필요하다면 더 공부하는게 정석이 아닐까.

솔직히, 자컴운알데네같은 과목은 그냥 이런거 고민하지말고 닥치는데로 다 외우는게 맞다. 솔직히 그렇게 난해하거나 무자비하게 양이 많은것도아니고.
근데, 이산수학, 프언같은 과목을 모두 다 외우려고 하는게 맞을까?
물론 지금처럼 가끔 저 과목들의 지식이 튀어나오거나 필요할 때가 있다. 꽤나 드물게 말이다.
그러면 여기서 포인트는 '이런게 있었지'를 아는거.

사실 이런 PS문제를 풀 때 필요한 지식은 
답지를 보면 깨닫고 배울 수 있다. 즉, 미리 알고있지 않아도 문제가 되지 않는다는 얘기다.

실무는 PS가 아니다. 즉, 정답이없다.
내가 짠 코드가 어떻게 해야 더 좋아지고,
어디서 문제가있고, 어떻게 구조를 짜야하는지 개발자가 직접 결정해야한다.
그리고, 꽤나 많은 케이스에서 구글 검색을 해도 나오지않는 문제에 봉착할때가있다. 혹은 최선의 해결책을 모를 때가있다.
(아마 그런거 같던데, 면접 질문으로 이런거 그쪽 회사에서 어떻게 해결했나요 하고 물어봤다고 하는거 보면)

그렇다면, 이때는 배경지식이 빛을 발한다. 무얼 어떻게 적용해야 효율이 좋아지는지 전혀 알수가없다.
수학문제를 풀 때, 미적분, 연립방정식, 뭐 다른 공식등등 본인들의 도구를 총 동원하는 것처럼,
실무에서 평소와는 다른 설계문제에 봉착했을 때 여러가지 본인의 도구를 사용해야한다.
근데, 이때, 본인이 알던 지식이 다 정확하게 머리속에 박혀있을까?
솔직히, 당연히 그럴 수 없다. 다만, 뭔가 들어본게 있으니까<<<<-
그걸 구글링해가면서, 다시 기억해가면서, 써먹는거지.(이때가, '이런게 있었지'를 써먹는 때다.)

근데, 사실 대부분의 실무는 거진 반복적인 작업과 이미 해당 업무를 위해 자주쓰이는 지식내에서 해결된다.
그래서 사실은 연구개발하는거 아니면, 혹은 한달에 한번 꼴로 발생하는 해결되지않는 에러에 직면한게 아니면,
굳이 이런걸 배우려고 애쓸 필요는 없는거 같긴하다.

게다가, 좀 극단적으로 기계공학전공으로 설비기술자인 사람이 생명공학의 DNA론같은걸 알아야 될 필요는 없다.
그냥 교양일 뿐이지.
미술지식? 몰라도된다..

깊은 화학지식, 전자지식?? 몰라도된다.
근데 화학,전자는 사실 알면 좋곘지. 이건 본인의 실무와 연관이 꽤나 될법하니까.
특히, 전압이나, 위험물 폐기물관련 화학전자지식?? 이건 필수겠지. 

결론은, 어느정도까지 습득해야하는지를 본인이 직접 판단, 어림짐작 할 수 있어야한다.

근데 어려우니까,

게다가 컴과같은 경우, 이런식으로 접근하면,
백엔드개발자는 프론트엔드, UIUX, PM지식도 알면좋다.
더 넓게 가면, 인공지능, 전자통신, 그래픽모션도 혹시 쓸지도 모른다.
=>이런식으로 접근하면 끝이없으니까.

우선 (가장기반인)CS를 제대로 학습하고,
[왜냐, 일단 CS는 모든 컴과 계열 직업의 기반이니까. 일단 배워두면 쓰인다는게 확실하다.]
그다음 실무를해보고
점차 늘려가는게 좋겠다.

근데 CS도? 사실 모르겠다.
그래서

결론적으로, 
1)학부 수업의 내용은 생각보다 쓰일 때가 있다.
2)그렇다고 모든 내용을 실무에 쓰일것 처럼 외우는 건 낭비다. 다만, 
[이런게 있었다.]정도로 머리속에 꼭 기억하고, 실무에서 아 이런게있었지.
뭐였지? 하고 그걸 써먹을 수 있을정도. 그정도만 공부해도 충분하다.
(물론 대놓고 중요한 과목, 중요한 내용은 그냥 외워서 알고 있어야한다.)
]

*/














/* 개인적인 고민
막상 코테에서
이게 dp문제인 걸 눈치 챌 수 있을까??

n의 범위가 (0~1000)인걸 보고 눈치채야됨.
-> 전에 봤었던 입력 변수의 범위보고 문제 유형 파악하는 블로그 글귀 보기.

- bfs,dfs / dp (대개 o(n)의 복잡도를 가짐, n이 좀 커도 됨.)
- 브루트포스 (단순 입력 반복, n의 제곱수의 복잡도를 가짐. n이 적당한 수여야함.)
- 백트래킹 (n이 10이상이면 적용하기 어려움 n이 커지면 연산 기하급수적으로 늘어남)

분류하기.(시뮬레이션은 문제 유형자체가 다른 거랑 달라서 눈치채기 쉬울 듯.)
[허용되는 시간제한에 따라서 시간복잡도/공간복잡도 분석하고 고르기.
1초에 대략 4000만번 연산.]

*/