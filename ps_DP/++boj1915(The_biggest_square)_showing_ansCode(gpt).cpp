//gpt한테 물어봄. [map이 주어졌는데 dp문제인 경우]

//와 이거보고 dp인줄 알 수 있을까??
//map준거 보고 무조건 bfs인줄 알거같은데.
//dp문제를 많이 풀어봐서 이런거 구별하는 안목을 기를 필요가 있음.

#include <iostream>
#include <algorithm>
using namespace std;


int n,m;
int d[1000][1000]; 
//d[i][j]=i행, j열까지만 범위를뒀을때, 그 범위내에서, 각위치에서 만들 수 있는 정사각형의 최대크기.

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m;
    int in;
    //입력받고 배열에 분류
      for(int i = 0; i < n; ++i){
        string s;
        cin >> s;
        for(int j = 0; j < m; ++j)
            d[i][j] = s[j] - '0';
  }
    /*
    for(int i=0; i<n; i++) {
        cin>>in;
        for(int j=m-1; j>=0; j--){
            d[i][j]=in%10;
            in/=10;
        }
    }  
    //이게 틀린 코드였음. ->정답코드 방식 인용하니 통과.
    =>왜 틀렸는가?
    int로 받았기 때문에 cin>>in에서
    in의 자리수가 int범위를 넘기면 오버플로우!!가 발생.
    따라서 이 방식으로는 1000자리수 까지 모두 담을 수 없으므로 불가능한 방법임.
    long long이든 뭐든 1000자리수는 불가능함.
    */

    //i=0 인 행, j=0인 열은 처음 대입한 값이 초기값.
    for(int i=1; i<n; i++)
        for(int j=1; j<m; j++){
            if(d[i][j]==1) d[i][j]=min({d[i-1][j], d[i][j-1], d[i-1][j-1]})+1;
            //잘 생각해보면, 세개중 최소값에서 +1되는 값을 가짐을 알 수있음.
        }
    //max찾기
    int mx=0;
    for(int i=0; i<n; i++){
        mx=max(mx, *max_element(d[i], d[i]+m));
    }


    cout<<mx*mx;
}

/*
[gpt 힌트]
(1)
이 문제는 **DP(동적 계획법)**를 사용하여 해결할 수 있는 전형적인 문제입니다.

힌트:
!!!!!!!!!!!!!!!!!!!!현재 위치에서의 정사각형 크기는 왼쪽, 위, 왼쪽 위 대각선의 정보를 활용하여 구할 수 있습니다.
!!!!!!!!!!!!!!!!!!!!DP 배열을 정의해서 각 위치에서 만들 수 있는 정사각형의 한 변의 길이를 저장합니다.
조건을 만족할 때, 현재 위치에서 만들 수 있는 정사각형의 크기를 갱신하며 최댓값을 추적합니다.
문제에서 요구하는 최종 정답은 가장 큰 정사각형의 넓이입니다.
이전 문제들과는 다르게 2차원 배열의 관계를 활용해야 한다는 점이 중요합니다. 각 위치를 중심으로 확장 가능한 최대 정사각형을 생각해보세요.

!!!!=> 첫줄, 둘째줄이 사실상 (1)dp 확산 방법->즉 점화식을 의미. (2)테이블 정의
dp의 핵심요소를 다준거라
사살싱 정답을 준거나 다름없음.

(근데도 살짝 고민하고 코드썼음. 예외케이스등 있지않나 생각, 왜이렇게 되나 생각.)


ㅁ 교훈
dp문제를 풀때는
(1) 무조건 점진적으로 풀 수 있게끔 생각해야한다.
    ->dp과정에서 마치 bfs코드처럼 추가 작업이 너무 많이 일어나면 안된다. (이런 경우 거의 dp문제의 코드가 아님 최소한 골드수준에선)
(2) 확산과정을(즉 점화식을 깔끔하게 떨어지게끔, 그 범위안에서만 고려할 수 있게끔.)위해
    범위를 한정지어야한다.
    [이 문제의 경우 정사각형을 체크하기위해 <왼쪽>,<위>,<왼쪽 위 대각선> 으로 체크 범위를 한정
<!중요!>게다가 i*j위치 까지만 봄으로써 오른쪽과 아래, 오른쪽 아래 대각선등 범위 외 경우의 수를 체크하지않아도된다.]

-> 사실상, 테이블 정의까지는 어떻게 생각해볼 수있는데
dp확산 과정 특히, 왼쪽, 위, 왼쪽위만 보면서 정사각형을 체크해나가는 방식을 생각해 내기가 너무어려움.
(이렇게 왼쪽, 위, 왼쪽 위 대각선 만 한정하지 않으면)
0111
0111
1111
1100
대충 이런 경우에서 3번째행, 2번째열 1의 경우, 오른쪽에는 3인 정사각형이, 왼쪽에는 2인 정사각형이 존재함.
지금 다시보니, 이것도 뭐, 본문 코드 방식 적용하면 될 것 같은데 전방향을 비교하도록 하면 꽤나 복잡해짐.
(어디서부터 체크하지? 이전건 어떻게 업데이트하지? 등)
게다가 테이블의 정의, 확산방식을 본문코드처럼 하지 않고 다르게 하는 경우. 이 문제는 더더 복잡하게 다가옴.


=> 어쨌든, gpt힌트를 토대로 풀었음.
처음엔 d[i][j]가 1인경우
왼쪽, 왼쪽위, 위 부분이 모두 같을 때 d[i][j]+1 하도록 했는데

이건, 왼쪽, 왼쪽위, 위 부분 중 하나라도 다른 경우(이경우를생각못했음.)
에도 i,j에 정사각형이 생길 수 있음을 간과했음.

잘생각해보니, 왼쪽/왼쪽위/위 방향의 정사각형의 최소값 +1 한게 d[i][j]가 될 수 있음을 체크.
그걸 점화식에 적용함.

근데 통과가 안돼서 정답코드 방식봣는데 동일함.
-> 입력받는 방식을 정답코드 방식대로 수정하니 통과.
->왜안된건지?? 체크필요
    =>왜 틀렸는가?
    int로 받았기 때문에 cin>>in에서
    in의 자리수가 int범위를 넘기면 오버플로우!!가 발생.
    따라서 이 방식으로는 1000자리수 까지 모두 담을 수 없으므로 불가능한 방법임.
    long long이든 뭐든 1000자리수는 불가능함.

=>근데 사실, 
원래 나도 처음에는 string으로 받으려했음.
근데 이게, string s;에
cin>>s하고
0110을 입력하면
0110입력을 받는게 아니라 110을 입력받는건지 제대로 안됐음.!
(다시 생각해보니, char에서 0은 48, 1은 49이므로, 0110의 경우 48494849가 출력된것으로 추측)
--->근데 지금보니, 그건 코드 상에서 직접적으로 s=110같이 대입했을 떄 그런거고
입력으로 0110을 주면 정상적으로 string으로받는걸 확인함
[기억하기. 앞으로 이런식으로 입력이 주어지면 항상 string으로 받기]

다만 이 정답코드의 방식처럼.각 문자에 대해 
  -'0'  을 해줘야함
  why? string, 사실상 char형 배열이므로, 각 요소는 char형과 동일함.
  숫자 1/0이 아닌 아스키코드값을 가진 문자이므로
  char형식인 '1', '0'에서 '0' 을 빼주어 
  숫자 int인, 1,0으로 변환시켜준것.
  (참고로 '1'은 49, '0'은 48로 char에서 저장됨.)
[교훈, string으로 받을 때는 꼭, 정해진 형식에 맞게 다시 가공해야함.]


*/

/*
실수기록
1)입력에 띄어쓰기 없으면 i,j따로 못받음. 일단 string으로 받아야됨.
2)입력받는 방식 -> 위 주석에 입력받는 방식이 왜 잘못됐는지 설명에 적어놓음.

*/