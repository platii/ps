#include <iostream>
using namespace std;

int n, m;
int d[41]; //d[i]=고정석이 0개일 때, 자석개수가 i인 경우, 사람들이 좌석에 앉을 수 있는 방법의 가짓수
int ans=1; //방법은 최소한 1가지는 존재하므로 초기값은 1

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    cin>>m;
    //d[i]배열 우선 채우기
    d[0]=1; //나중에 ans구할 때 사용됨. ->d[0]이면 ans에 곱해질 때 그냥 ans 값을 유지시킴.
    d[1]=1;
    d[2]=2;
    for(int i=3; i<=n; i++){ //!!!!실수, 초기값 0,1,2대입했는데 i=0부터 for문돌림 -> 오류남.
        d[i]=d[i-1]+d[i-2];
        //점화식 도출 과정
        //1) 맨처음 1을 옆 자리와 교체하지 않았을 경우 -> 남은 i-1좌석을 서로 제한 없이 교체헀을 때 좌석에 앉을 수 있는 방법의 가짓수
        //2) 맨처음 2를 옆자리와 교체(21 ~~ 나머지) ->21 을 제외한 남은 i-2개 좌석을 //
    }
    int fN; //고정석 fixed_sheet_number
    int pre_fN=0;
    while(m--){
        cin>>fN;
        ans*=d[fN-pre_fN-1]; 
        pre_fN=fN;
    }

    ans*=d[n-pre_fN]; //마지막 고정석 뒤에 블럭의 가짓수 더해주기.

    cout<<ans;
}

    //풀이과정 -> 고정석 사이 사이 공간은 d[fN-pre_fN-1]과 같이, 
    //예를들어 고정석 3,7사이 공간은 3개의 일반석 좌석에 앉을 수 있는 방법의 가짓수를 구하면됨. 
    //이 풀이로, 계속 사이사이 블럭의 가짓수를 곱해준 것. (경우의수의 곱법칙)

    /*
    경계조건 등 커버해야할 경우의 수.(sound한 방법으로 알고리즘의 유효성 체크)

    1)고정석 사이의 일반석 경우의수 -> 커버가능
    2)고정석 바로 옆에 고정석이 있는 경우(즉, 고정석 사이에 일반석이 없는 경우) 
        -> d[0]=1을 곱하게되므로 가능(고정석을통해 추가로 만들 수있는 경우의 수는 없으므로 이전의 값을 그대로 이어감).
    3)마지막 고정석 이후의 일반석 -> 마지막 줄에서 커버함.
    4)모두 고정석으로 채워져있는 경우 -> 총 가짓수 는 ans그대로인 1이됨, 커버가능
    5)고정석이 없는 경우 -> 역시, 마지막 줄에서 처리 가능함. pre_fN이 0일 것이므로. 
        =>따로 if(pre_fN==0) 과 같은 장치를 사용하지 않아도 처리가 가능함.

    기타, 좌석수가 1개인 경우, 맨 앞자리인 1좌석이 고정석인 경우 등등-> 커버가능함.
    */

   /* 정답코드랑 비교
   ->정답코드도 풀이, 접근법은 거의 동일하다고 보면됨.

   다만, 정답코드의 경우. vector를 사용했고.
   vector를 사용하여 고정석들을 미리 벡터에 저장해두었음. (v.push_back사용)
   근데, 마지막 자리에 n+1을 push_back하여
   직접 푼 코드처럼
   for문 밖에서 마지막 고정석 이후의 일반석 경우의수를 처리하는 게 아니라.
   for문 내에서 모두 처리하도록 했음.

   //아래는 정답코드의 방식임
    while (m--) {
        cin >> vv;
        v.push_back(vv);
    }

    ~~~점화식을 통해 d배열 채우는 코드들~~~

    v.push_back(n + 1);
    int ans = 1;
    for (int i = 1; i < v.size(); i++) ans *= d[v[i] - v[i - 1] - 1];
    cout << ans; 

   */