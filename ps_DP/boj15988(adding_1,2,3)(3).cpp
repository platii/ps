#include <iostream>
using namespace std;

typedef long long ll;

int t,n;
ll d[1000001];
//d[i]=i를 1,2,3의 합으로 나타낼 수 있는 경우의 수

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>t;
    d[1]=1LL;
    d[2]=2LL;
    d[3]=4LL;
    for(int i=4; i<=1000000; i++){
        d[i]=(d[i-1]+d[i-2]+d[i-3])%1000000009; //10억대로 나누었으므로 int범위 안에 들게 됨.
        //실수!! 근데, 3개 다 더하면 21억 넘길수도있음. 그럼 int 범위 넘어섬
        /*
        해결법1) ll사용하기 ->1백만개라 충분히 가능
        해결법2->불가능) !!불가능한 방법!! -> 결론 int써서는 안됨.
                modV=1000000009; 로 정의하면
                (d[i-1]%modV+d[i-2]%modV+d[i-3]%modV)%modV; 를 쓰는걸 생각해 봤는데
                잘 생각해보니 어짜피 괄호 안 각각의 수가 10억이 될 수 있음+세 수를 더하면 21억을 넘길 수 있으므로 
                이방법은 불가능함.
        */
    }
    while(t--){
        cin>>n;
        cout<<d[n]<<'\n';
    }

}

//점화식 선정이유? => dp에서 2*n문제의 접근 방식이랑 거의 동일함.
//앞자리에 1을 먼저채우면 나머지는 남은 i-1을 1,2,3으로 만들 수있는 경우의수
//앞자리에 2를 먼저 채우면 // i-2를 //
//~->과 같은 방식을 통해 점화식을 도출.

/*
정답코드
(해결법2 방식에서, 이번엔 가능한 솔루션)
  for(int i = 4; i <= 1000000; ++i)
    for(int j = 1; j <= 3; ++j)
      d[i] = (d[i] + d[i-j]) % mod;

1개의 최대치는 10억이니
int의 범위인 21억을 넘기지 않도록

맨처음엔 d[i]=0으로 초기화.
그다음
d[i-1], d[i-2], d[i-3]을 차레로 하나씩 mod덧셈법칙 적용하여 mod를 계산함.
<mod덧셈법칙 = (a+b)mod x=(a mod x + b mod x)mod x>
*/