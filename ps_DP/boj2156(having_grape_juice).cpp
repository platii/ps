#include <iostream>
#include <algorithm>
using namespace std;

int n;
int a[10001];
int d[10001][3]; //d[i][j]=현재 인접길이가 j일때 i번째 index까지 먹은 포도주 양의 최대값.

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    for(int i=1; i<=n; i++){
        cin>>a[i];
    }
    for(int i=1; i<=n; i++){
        if(i!=1) d[i][2]=d[i-1][1]+a[i];
        d[i][1]=d[i-1][0]+a[i];
        d[i][0]=max({d[i-1][2], d[i-1][1], d[i-1][0]});
    }
    cout<<*max_element(d[n], d[n]+3);
}


//정답코드 별해와 거의 정확히 일치함.
//-> 단지 정답코드는 d[1][1]=a[1];를 초기값으로 두고 i=2부터 for문을 돌렸음.

//정답코드의 방식(별해 아님) 확인
/*
  d[1] = a[1]; d[2] = a[1] + a[2];
  for(int i = 3; i <= n; ++i)
    d[i] = max({d[i-1], d[i-2] + a[i], d[i-3] + a[i-1] + a[i]});
  cout << d[n];
//
d[i]=i번째인덱스에서 마신 포도주의 최대치 로두고

위와 같이 max식을 작성, i=3부터 for문을 돌림.

[경우의수 3개
1) i번째 인덱스에서 포도주를마시지 않은 경우 (인접길이 0) 
    -> 이전 인덱스의 d값을 이어받음
2)        //       인접길이 1인 경우
    [(인접길이 1이라는건 이전칸은 섭취하지 않았다는 것이므로)]
    -> i-2 칸에서의 d와 a[i]를 더해줌.
3)        //       인접길이 2인 경우
    [(인접길이 2라는건 i-3에서 i-2인덱스는 건너뛰고, 현재 인덱스 i와 이전인덱스 i-1에선 섭취한 것이므로)]
    -> d[i-3] + a[i-1] + a[i]


]

*/

/*
feedback
실버1 문제 ->40분 소요
(최소한 20분 이내로 단축해야함.)

40분이나 소모하지 않기 위해서는?
*****
1) dp문제의 경우 우선 수열이 제시되는 경우가 많음.
   이때, 주의해야 할 점은 앞에서부터 차례로 고려해야한다는 점임(혹은 끝점부터)
   중간부터 보게되면, 점화식도 눈에 안들어 올 뿐더러 혼란만 가중됨.

2) (1)의 연장으로, dp문제의 경우 
   풀이법이 확실히 떠오르지 않는 경우가 빈번하게 있음. 
   [본문같은 문제는 나름대로 확실히 떠오르는 편이고, 매우 어려운 문제의 경우]
   예를들어, 임의의 dp문제에서
   d[i][j]= '~임의의 점화식~' 과 같이 대충 써놓기는 했는데,
   막상 이게 왜 이렇게 되는건지, 중간에 어떠한 과정에서 문제가 안 생기는지 그냥 긴가민가 한 경우가 있음.
   
   근데, 개인적인 생각으로는 dp는 처음부터 명확하게 점화식이 떨어지기 보다는.
   우선 생각나는 점화식을 사용해 보고, 맞으면 그대로 아니면 수정하는 방식으로 접근하는게 좋은 것 같음.
   (바로 식이 떠오르면 좋겠으나, 그러기 쉽지 않음. 
   그니까 비슷하게 점화식을 내볼 순 있으나 예외 케이스라던지 bound케이스라던지, 이전의 풀어본 dp유형이 아니라면
   한번에 점화식을 맞추기가 어려운 경우가 있음.)

3) [중요!!!!!!!]우선 경우의수를 먼저 생각해야함.(for문에서 기게적으로 i,j를 잡으면 안됨.)

   이 문제같은 경우도 
   for문에서 j=1 ~j<=2까지 범위를 기게적으로 작성해서 
   d[i][j]= ~~~~ 처럼 하려고했음.

   근데 막상, 점화식은 저렇게 j형식으로 떨어지지 않고.
   본문의 작성 코드처럼
   인접길이가 2일때의 식,
   인접길이가 1일때의 식,
   인접길이가 0일때의 식
   과 같이 나누어졌음.
   즉, 처음 혹은 끝부터 차례로 채우는 점화식을 풀때는
   [i][j]칸의 값이 어떤값으로 부터 오는지, 어떤 점화식으로 부터 오는지를
   명확히 나누어 정리해 볼(굳이 코드로 작성하지 않더라도 머리속에서 경우의수를 차근차근 나눠 봐야함.) 필요가 있음.


*/