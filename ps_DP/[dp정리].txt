
개인적으로,
dp는

1. 테이블 정의
2. 점화식 찾기
3. 초기값 대입

이것만 기억하면 끝임.

점화식 찾기가 어려워서 그런것.

[2025.2.1] 그래도 어느정도 기존의 틀을 따라가는경우가 많음, 다만 showing_ansCode인건 도저히 발상이 안떠오르는
           새로운 발상의 문제라 답을 본것이니 꼭, 한번 보고 갈것.!
           =>인상깊은 문제는 앞에 ++표시함.

프로그래밍은 기법은 1,2,3이 전부고,
나머지인 점화식찾기가 넌센스퀴즈와 같음.
->사실상 점화식 찾기가 dp의 전부임.(다만 max의 사용, n^2방식의 사용 등으로 알고리즘이 변칙적일 수는 있음.)

//실수하기 쉬운것(고려해야 하는 것)
1) int자료형을 써도 되는지
    수가 상당히 커지면 int범위(4byte 정수형)인 2의 31승을 초과하는 값이 나올 수 있음.
    - 이 경우, 보통 문제에서는 mod연산을 시키거나
    - 혹은 int자료형이 아닌 다른 자료형을 써야함.

    tip) 대략 20~30억을 넘기면, int를 초과한다고 보면됨. (0이 9개, 총 수의 개수는 10개)
    (2의 31승 = 2,147,483,648)

  1-1) long long 자료형[!*****!!!중요!!!!*****!]
   - 이 경우 int대신 보통 long long자료형(8byte 정수형)을 쓰게됨

   - 2의 63승 = 922경 = 19자리가짐 까지 표현 가능

   - 코드 앞에 typedef long long ll; 처럼 long long을 편하게 쓰기위해 typedef함.

   - 숫자 뒤 LL을 통해 long long임을 나타낼 수 있음.(정수는 기본적으로 int로 처리되므로 현재의 수가 LL로 저장되는 값임을 명시적으로 표현)
     //ex1) d[1]=1LL;
     //ex2) long long x = 10000000000LL; // long long 타입으로 10억을 저장

//팁
1) 테이블을 먼저 다 계산해두고, 그 다음에 답을 출력하는 것이 편함. 그리고 매번 질의문에 대해 계산하는 것 보다 효율적.
2) 구간합(prefix sum)을 다른 문제에서, 시간복잡도를 줄이기 위한 기법으로 사용될 수 있음. 따라서 이를 잘 숙지
3) 만약 처음부터 점화식과 그것이 도출된 이유가 깔끔하게 생각나지 않으면, 일단 직접 d[1],d[2]...를 직접 몇개 계산해보고
    유추하면서 시작하는 것도 나쁘지 않음. {일단 점화식을 구하고, 나중에 그게 도출되는 이유를 찾아도 실전에선 뭐 괜찮을듯.}

//문제 유형
1)일반적인 dp문제
2)dp의 경로를 묻는 문제[!!!!!알아두자!!!!!]
-마지막에 경로를 계산하는 방법 
=>지시문(처리해야할 입력줄의 수)이 적은 경우 효율적 [distance배열 채우는 과정에서, 경로를 저장하는 연산을 시행하지 않으므로]

-경로를 미리 배열에 다 저장해두는 방법.
=>지시문이 여러개인 경우 효율적
[2025.1.27 추가!!!] 근데, 직접 해보니 그냥 이방법으로, 
                    pre배열통해서 경로를 미리 배열에 다 저장해 두는게 가독성도 좋고 코드짜기 편함.

===> 1로만들기2 문제 참고 (boj12852(make_it_one2))

3)2차원 배열 dp
3)테이블에 채우는 순서가 복잡한 dp




//문제를 풀때, dfs-bfs/dp/백트래킹 중어떤걸 골라야하나?
+[2025.1.28] n이 1000~1000000정도로 크고, 맵이 안주어졌는데, 수열같은 형식으로 쭉 주어지면 웬만하면 dp
!!!!!!!특히!!!!!!!! 10007로 나눈 나머지 이런거 들어가면 거의 90프로 dp.

/* -> 이친수 문제 참고 boj2193(pinary_number)
혹시 이 문제를 dp가 아닌, 백트래킹 or dfs로 풀 수 있을까?

- 우선 dfs는 미로찾기처럼, 맵이 주어져있어야 큐에 원할하게 넣을 수 있다.
  만약, 앞자리수가 0일때와 1일때로 나눠 dfs를 하더라도 이는 백트래킹과 큰 차이가 없을 것이다.
  이 경우, 올바르지 않은 경로에 도달하면 자동으로 취소하고 다음 경로를 진행하는 백트래킹이 효율적일 것이다.
  (문제를 많이 풀어보지 않아서 확답할 순 없지만, dfs/bfs 문제의 경우 맵이 주어진 경우 효율적
  bfs의 경우 "1로만들기" 문제처럼 '거리'를 구하는 문제에서 효율적.
  )

- 그럼 백트래킹은 어떨까?
  백트래킹의 경로는 m-way 트리로 나타낼 수 있다.
  따라서 시간복잡도는 o(m^n)이 되고, 해당 문제의 경우 0과1로 m이 2개이므로
  o(2^n)
  2의 n승인경우 n이 10이면 1024번 반복,
  2의 20승은 100만번
  2의 "24"승 부터 1000만번을 넘어간다.(약 1600만번) 즉
  !!!!!!!!!!백트래킹의 경우 n이 24가 될때부터 1초안에 실행하기 힘들다는 소리. !!!!!!!!!!!!!!!!
  (더 예상해보면 25를 넘기는순간부터 1씩 증가할 때마다 알고리즘을 위해 2초, 4초~씩 필요하게 될것임.)
  즉 문제에서 n의 범위가 20 아래인경우 백트래킹으로 풀만하지만

  넉넉히 n이 30을 넘기면 백트래킹으로 풀 수 있는 문제가 아니다.(상당한 시간이 소요되므로)
  즉 이 문제는 n의범위가 0~90이므로 백트래킹으로 풀 수없음.

  따라서 이문제는 dfs,백트래킹,dp 중
  dp를 쓰는 것이 효율적인 문제임.

  문제를 풀 때 어떤 알고리즘을 써야하는지 알기어려움.
  1)따라서 일단 n의 범위를 보고 30 이상이면 ->백트래킹 불가.(보통 백트래킹문제는 입력 범위가 0~10정도.)
  2)맵이 있는 문제는 dfs,bfs가 편리
  3)그러나 이런식으로 범위가 정해지지 않은 문제는 
    dfs나 백트래킹이나 모두 트리형태로 범위가 주어짐.
    -> 이럴 땐 그냥 dp
    (트리형태는 시간복잡도가 높고, 이런식의 문제에선 백트래킹 원치않은 경로는 더이상 가지 않고 다른 경로에 대해 진행하므로
    dfs가 효율적임. 근데 n이 30을 넘기므로 둘다 쓸 수 없는 문제임)

*/

////////////////////////////////////////////////////////////////////////////
//dp문제를 간단하게 접근하기 위해서(문제를 푸는데 들어가는 시행착오를 줄이기 위해서) 
  문제를 풀기 전 인지해야하는 것.
  [ex, 수학수능 문제를 풀 때, 풀이방식이 바로 떠오르지 않아 문제에 사용될 수 있는 식이나 문제에서 파생되는 계산식을 마구 적는데
  여기서 문제에 필요 없는 식을 적는건 시간 낭비임. 
  그러나, 현실적으로 바로 답을 떠올리는건 약간 어려움. 그러므로 잔 실수를 하지 않도록 아래의 세 point를 명심해서 문제를 접근하기]
  (3번 포인트가 제일 중요.->불필요한 타이핑시간, 점화식을 확실하게 정하지 못해 아이디어와 생각이 붕 뜨는걸 방지)


feedback
실버1 문제 ->40분 소요
(최소한 20분 이내로 단축해야함.)

40분이나 소모하지 않기 위해서는?
*****
1) dp문제의 경우 우선 수열이 제시되는 경우가 많음.
   이때, 주의해야 할 점은 앞에서부터 차례로 고려해야한다는 점임(혹은 끝점부터)
   중간부터 보게되면, 점화식도 눈에 안들어 올 뿐더러 혼란만 가중됨.

2) (1)의 연장으로, dp문제의 경우 
   풀이법이 확실히 떠오르지 않는 경우가 빈번하게 있음. 
   [본문같은 문제는 나름대로 확실히 떠오르는 편이고, 매우 어려운 문제의 경우]
   예를들어, 임의의 dp문제에서
   d[i][j]= '~임의의 점화식~' 과 같이 대충 써놓기는 했는데,
   막상 이게 왜 이렇게 되는건지, 중간에 어떠한 과정에서 문제가 안 생기는지 그냥 긴가민가 한 경우가 있음.
   
   근데, 개인적인 생각으로는 dp는 처음부터 명확하게 점화식이 떨어지기 보다는.
   우선 생각나는 점화식을 사용해 보고, 맞으면 그대로 아니면 수정하는 방식으로 접근하는게 좋은 것 같음.
   (바로 식이 떠오르면 좋겠으나, 그러기 쉽지 않음. 
   그니까 비슷하게 점화식을 내볼 순 있으나 예외 케이스라던지 bound케이스라던지, 이전의 풀어본 dp유형이 아니라면
   한번에 점화식을 맞추기가 어려운 경우가 있음.)

3) [중요!!!!!!!]우선 경우의수를 먼저 생각해야함.(for문에서 기게적으로 i,j를 잡으면 안됨.)

   이 문제같은 경우도 
   for문에서 j=1 ~j<=2까지 범위를 기게적으로 작성해서 
   d[i][j]= ~~~~ 처럼 하려고했음.

   근데 막상, 점화식은 저렇게 j형식으로 떨어지지 않고.
   본문의 작성 코드처럼
   인접길이가 2일때의 식,
   인접길이가 1일때의 식,
   인접길이가 0일때의 식
   과 같이 나누어졌음.
   즉, 처음 혹은 끝부터 차례로 채우는 점화식을 풀때는
   [i][j]칸의 값이 어떤값으로 부터 오는지, 어떤 점화식으로 부터 오는지를
   명확히 나누어 정리해 볼(굳이 코드로 작성하지 않더라도 머리속에서 경우의수를 차근차근 나눠 봐야함.) 필요가 있음.
*/
////////////////////////////////////////////////////////////////////////////