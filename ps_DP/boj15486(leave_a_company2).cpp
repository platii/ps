//퇴사1 문제와 동일함.
//단지 n의 범위가 1~15에서, 1~1,500,000으로 늘었을 뿐.
#include <iostream>
#include <algorithm>
using namespace std;

//typedef long long ll;       ll안하고 int로 해도됨. int 범위안에 유효함.

int const MAX=1500001;
int d[MAX], t[MAX], p[MAX];
int n;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    for(int i=1; i<=n; i++){
        cin>>t[i];
        cin>>p[i];
        //cin>>t[i]>>p[i];
        //로 간단하게 쓸 수 있음.
    }
    d[n+1]=0;
    for(int i=n; i>=1; i--){
        if(i+t[i]<=n+1) d[i]=max(d[i+t[i]]+p[i], d[i+1]);
        else d[i]=d[i+1];
    }

    cout<<*max_element(d+1, d+n+1);
}

/*
시간복잡도 분석
-dp는 보통 o(n)이므로, 150만 정도는 문제없음.(1초는 보통 1억회 연산, 대략 1000만번 반복이 가능하다고 보고 문제를 품)

공간복잡도 분석
-512메가가 문제의 공간제약으로 주어짐.
-4메가당 대략 1백만개, 128메가에 3200만개의 int저장가능
-512메가면 대략 1억개는 넘개 저장가능 즉, 150만개 저장은 문제없음.
-배열이 t배열,p배열,d배열 총 3개이므로 대략 450만개의 int저장필요.

=>그런데 ll을 저장하면?
- ll은 4바이트가 아닌 8바이트 정수형임.
- 따라서 int자료형의 두배, 그렇다 치더라도 대략 450만*2 = 900만개의 int를 저장하는 것과 동일한 용량을차지함.
- 이정도는 무리없음.

*/

//그럼 뭐가 다른걸까. 퇴사1이랑? 아마 배열의 자료형으로 int를 쓰면 오버플로우나고, ll을 쓰면 잘될 것으로 추정됨.
//일단 퇴사1과 동일한 코드에 ll로하니 통과함.
//근데 int로 해도 통과함 왜? p의 최대값 1000과 n의 최대값 150만 을 곱해도 15억이 끝임.
//즉 int의 범위인 약 21억을 넘지 않으므로 괜찮음.