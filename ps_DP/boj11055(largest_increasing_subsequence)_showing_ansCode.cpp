//정답코드 본 문제/
#include <iostream>
#include <algorithm>
using namespace std;

int a[1001]; //arr
int d[1001]; //d[i] = i번째 인덱스까지, 수열내에 존재하는 증가하는 부분수열의 합의 최대값

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin>>n;
    //수열 입력 받기
    //+ d[i]에 a[i] 복사하기
    for(int i=0; i<n; i++){
        cin>>a[i];
        d[i]=a[i];
    }
    //계산
    for(int i=1; i<n; i++){
        for(int j=0; j<i; j++){
            if(a[j]<a[i]) d[i]=max(d[i], d[j]+a[i]);
        }
    }
    cout<<*max_element(d, d+n);    
}

/*
ㅁ 정답코드확인함.

a. 방법.
첫index부터 차례대로,
해당 인덱스에서 가능한, 합이 최대인 부분증가수열의 합을 찾는다. ->o(n)
[해당 인덱스에서 이전 인덱스의 합이 최대인 수열에서 증가수열로 이어질 수 있는 경우 합을 계산하는걸, 처음부터 해당인덱스까지 진행하는것
그냥 코드보고 이해하는게 이해하기 편함.]
모든 인덱스에 대해 이 작업을 수행한다. -> o(n)

총 시간복잡도 o(n^2) 

b. 가져가야할 발상.
    이전의 연속합문제(boj 1912, 주어진 수열에서 몇개를 골라서 가능한 합의 최대값 구하기)에서 
복잡하게 생각하지말고, 인덱스의 처음부터 계산하는 발상으로 해당 문제를 풀 수 있음과
max함수를 사용하여 이를 간단하게 표현할 수 있음. max함수내에 + 연산을 하여 더 간단히 표현할 수 있음을 확인하였음.

    해당 문제에서는 
o(n^2),
즉, 이전처럼 o(n)이 아니라,
시간만 허락한다면 해당 인덱스에서 o(n)
모든 인덱스에 대해 진행하므로 
총o(n^2)
이런식으로 접근이가능함을 얻어갈 수 있었음.

*/



/* 읽을 필요x, 그냥 메모) 문제풀면서 고민했던점.

뭔가 정답코드처럼, 각 인덱스까지의 -합이 최대인 부분수열의 합-을 찾고 하려고했는데,
내가 생각했던건, 단순히 처음부터 그 index까지 증가하는 수열을 찾아 합을 기록하는 것이었음.
그래서, 각 수열을 연결하는 걸 생각했음.
근데 이러면, 뒤에있는 수열의 중간지점과, 앞에있는 수열의 중간부분을 이은게 -원래 합이 가장큰 증가하는 부분수열-이라면
못구함.
그래서, 각 부분별로 앞이랑 비교해서 합을 찾는걸 생각했는데,
이렇게하면 시간복잡도가 n^n으로 미쳐날뛸것.
그래서, 이거말고 생각이 안나서 방법을 못찾아서,
그냥 정답코드 체크함.
*/