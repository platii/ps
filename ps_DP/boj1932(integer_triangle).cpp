#include <iostream>
#include <algorithm>
using namespace std;

int tr[501][501]; //앞대괄호는 삼각형의 깊이(맨위가1), 뒷대괄호는 해당 깊이에서의 각 칸을 의미
                  //테이블 정의 : i깊이 j칸(위에서 아래로)까지 더했을 때 그 경로에서의 최대값(해당칸도 더함)

//tr은 필수로 모두 0으로 초기화되어있어야함!! 중요!!->트리의 맨왼쪽에서 i-1,j-1에 접근할때, 맨오른쪽에서 i-1,j에 접근할때 더해질 0값.
//전역으로 선언하였으므로 모두 0으로 초기화 되어있음.

/*
예를들어 크기5짜리 삼각형이면,
                     tr[1][1]
                tr[2][1]   tr[2][2]
           tr[3][1]   tr[3][2]   tr[3][3]
     tr[4][1]   tr[4][2]   tr[4][3]   tr[4][4]
tr[5][1]   tr[5][2]   tr[5][3]   tr[5][4]   tr[5][5]

ex) tr[2][1]=max(tr[1][0], tr[1][1])이됨, 이때 tr[1][1]값을 전달해주어야 하므로 tr[1][0]이 max연산에 지장을 주지않는 값이어야됨. (0이하의값)
맨오른쪽인 경우도 마찬가지임.
-> 즉 맨 아래칸을 제외하고, 나머지는 tr[i][1], tr[i][i] 칸의 왼쪽 오른쪽에 0이 있는것
트리를 0이 감싸고 있는구조.

(물론 tr[501][501]이라서, 매 깊이마다 0~500까지 초기에 0으로 채워있지만 쉽게, 트리만 생각했을 경우 위와 같이 표현가능)

*/

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n; //삼각형의 크기
    cin>>n;
    cin>>tr[1][1]; //초기값 대입 //n은 1보다 큰수
    for(int i=2; i<=n; i++){
        for(int j=1; j<=i; j++){
            int trV;
            cin>>trV;
            //그 윗칸에서의 최대값 + 현재 값
            tr[i][j]=max(tr[i-1][j-1], tr[i-1][j])+trV;
        }
    }
    /*
    //최대값 찾기
    int max=0;
    for(int j=1; j<=n; j++){
        if(max<tr[n][j]) max=tr[n][j];
    }
    cout<<max;
    */

    //max_element를 쓰는 방법(더 효율적)
        cout<<*max_element(tr[n]+1, tr[n]+n+1);
    /*
        //주의
        cout<<*max_element(tr[n][1], tr[n][n]+1);
        처럼 쓰면안됨.

        max_element는 iterator를 반환하는 함수이기 때문.
        주어진 주소 사이에서 max값을 찾아주는 함수임.(마지막 값은 +1해줘야, 함수 진행과정에서 -1해서 그 자리로 연산함. 주의)
        따라서 *을 통해 iterator가 가르키는 변수를 가져와야함.
        그리고, 이런식으로 사용하기 위해서는 내부의 처음과 끝+1인 "주소"를 적어야함.
    */
    //

}

//정답코드는 트리를 처음부터 다 입력받고 풀었는데 그럴필욘 없음. 본 코드가 나음.
//정답코드에선 max를 max_element함수를 활용해서 게산했음. <-이게 더 효율적 이걸 차용하자.

/*
1.테이블 정의
tr[i][j]=i깊이 j칸(위에서 아래로)까지 더했을 때 그 경로에서의 최대값(해당칸도 더함)

2.점화식 찾기
tr[i][j]=max(tr[i-1][j-1], tr[i-1][j]);

3.초기값 대입
cin>>tr[1][1]; (맨처음값)
*/