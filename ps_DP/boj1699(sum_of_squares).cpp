//제곱수(squares)의 합.
#include <iostream>
using namespace std;

int n;
int d[100001]; //d[i]=i를 제곱수들의 합으로 표현할때, 그 항의 최소개수. 

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    fill(d, d+100001, 100001);
    d[0]=0;
    for(int i=1; i<=n; i++){
        for(int j=1; j*j<=i; j++){
            d[i]=min(d[i], d[i-j*j]+1);
        }
    }
    cout<<d[n];
}

/*
그냥, coin_1문제, 혹은 이전의 문제처럼 d[]안에 수식에 제곱수를 빼서 계속 비교해주고,
o(n제곱)방식을 도입함.

/////
->ex) 
n=11대입했고, i가 11일떄, 
j=1이면,
d[11]=min(d[11], d[11-1*1]+1) -> 기존 초기값과, 1의 제곱수를사용했을 때의 최소항의 개수 비교
d[11-1*1]은 1의 제곱수하나를 포함하여 11을 구성할때 
1의제곱수를 사용한 경우 + (제곱수를 이용하여 10을 만들어낼 때 항의 최소개수)를 의미함.
d[11-2*2]는 2의 제곱수를 사용한경우 + (// (11-2*2)를 만들어낼 때 ...)//
....
...

/////

다만 max대신 min을 사용했고.
이를 위해 모든 값들을
주어진 문제상으로, d배열이 가질 수 있는 최대값 보다 더큰 값을 주어,
min비교에서 d배열의 초기값이 영향을 미치지 않도록함.

바킹독 dp문제집상 응용문제인것치고
lcs문제에 비해 굉장히 발상이 간단한 문제.

*/