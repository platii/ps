#include <iostream>
using namespace std;

int n;
int d[101][11]; //d[i][j]=길이가 i이고, i번째 수가 j일때 계단수의 개수, 를 1,000,000,000으로 나눈 나머지
//d[i][10]=0을 사용하기 위해 11크기(0~10)까지 선언함.

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    fill(d[1]+1, d[1]+10, 1); //초기값 채우기, i=1일때 1~9까지 d[1][j]=1;
    for(int i=2; i<=n; i++){
        for(int j=0; j<=9; j++){
            if(j==0) d[i][j]=d[i-1][j+1]%1000000000;
            else d[i][j]=(d[i-1][j-1]+d[i-1][j+1])%1000000000; 
        }
    }
    int sum=0; 
    for(int j=0; j<=9; j++){
        sum=(sum+d[n][j])%1000000000;
    }
    //!!실수기록!!
    // sum+=d[n][j]%1000000000; 로 하면안됨
    // sum이 int라 10억이 9개 더해지면 int범위를 넘어서기때문에
    // sum 연산반복에서 계속 d[n][j]를 sum과 더해준 값을 %1000000000; 연산 취하여 int범위 안에 들어오게 해야됨.

     //정답코드에선 그냥 sum을 long long으로 선언하고 for문 이후에 10억으로 모드연산 해버렸음.
     //이게 연산면에서 mod연산을 10번 반복하지 않고 마지막에 한번만 해도 되니 효율적이긴한데
     //어짜피 이전에 for문에서 n*9번 반복했기 때문에, 이 10번 정도의 mod 연산은 사실 큰 차이는 없음.

    cout<<sum;
}

//mod연산 복습 -> (a+b)mod x = ((a mod x)+(b mod x)) mod x

/*
단순히 생각해본 발상 -> 정답.
-> 2차원 배열 사용.

1. 테이블 정의
d[i][j]=길이가 i이고, i번째 수 가 j인 계단수의 개수
(맨 첫자리수는 0이아님, 나머지는 0~9가능)

2. 점화식 찾기
d[i][j]=d[i-1][j-1]+d[i-1][j+1];
(j=9일때 대비 d[?][10]=0으로 설정)
(j=0일때 만 d[i][j]=d[i-1][j+1]로 설정)

3. 초기값 대입
i=1일때 각 j칸은 모두 1
d[1][1]~d[1][9]=9
d[1][0]=0임

*/

/* 정답코드와 비교

접근 방법은 그냥 동일한 수준이고.

  for (int i = 2; i <= n; ++i) {
    for (int k = 0; k <= 9; ++k) {
      if (k != 0) d[i][k] += d[i - 1][k - 1];
      if (k != 9) d[i][k] += d[i - 1][k + 1];
      d[i][k] %= 1000000000;

다만 0과 9에서의 out of bound 처리를 위와같이 해줬음.
- 직접푼코드에서는 k=9일때는 그냥 d[i-1][10]=0을 사용해서 계산하고, 0일때만 다른 점화식을 적용한 반면
- 정답코드는 0인지 9인지 여부를 모두 체크하며 진행했음.(각각 0또는 9이면 해당 if문의 작업을 하지 않게하여 out of index 방지함)

큰 차이는 없겠지만
직접푼 코드가 for문 반복에서의 if문이 하나로, if문이 2개인 정답코드보다 적으므로
총 if문의 조건 비교 횟수가 적을 것.
따라서 굳이 따지자면 직접쓴 코드가 더 효율적일 것으로 추측.

*/