#include <iostream>
using namespace std;

int f0[41]; //0횟수 저장 테이블
int f1[41]; //1횟수  ~

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin>>t;
    //입력으로 받는 n의 범위가 0~40이므로, 우선 40까지 테이블을 모두 채운후에 나중에 출력함.
    f0[0]=1;
    f0[1]=0;
    f1[0]=0;
    f1[1]=1;
    for(int i=2; i<=40; i++){
        f0[i]=f0[i-1]+f0[i-2];
        f1[i]=f1[i-1]+f1[i-2];
    }
    while(t--){
        int n;
        cin>>n;
        cout<<f0[n]<<' '<<f1[n]<<'\n';
    }

}

/*만약 테스트케이스(지시문) 마다 테이블 채우기를 반복했다면? -> t(테스트케이스횟수)*40번을 반복했을 것. t는 제한조건이 없으므로 무한정커지면 
시간제약을 넘었을 것.
dp는 어지간하면 o(n)이므로 그냥 처음부터 테이블 다 채워도 500만정도 넘기는거 아니면 시간안에 다 채움. 그니까 그냥 초반에 다채우자.

/*정답코드는 f0, f1배열을 두지않고,2차원배열 한개 씀, f[i][k]로 두어서, k를 0과1로 한정함.
->ans코드 확인*/

/*
1. 테이블 정의
f0[i]=i를 fib함수에 인자로 전달 했을 때 0이 출력되는 횟수
f1[i]=              //              //         1이 출력되는 횟수

2. 점화식 찾기
f0[i]=f0[i-1]+f0[i-2];
f1[i]=f1[i-1]+f0[i-2];

3. 초기값 대입
f0[0]=1;
f0[1]=0;

f1[0]=0;
f1[1]=1;
*/



/* 시-공간제한
ㅁ 시간제한 0.25초
(1초에 1억번연산 가능, 대략 1000만번 반복연산가능으로로 잡음.)
(0.25초면 250만 반복 안에 끝나야함.)

ㅁ 공간제한 128메가.
int가 대략 4바이트
백만개면 대략 4백만바이트 -> 4메가바이트
(실제로 1키로바이트는, 1바이트가 1024개, 1메가바이트는 1키로바이트가 1024개인 것이므로 2의20승바이트가 1메가임)
(따라서, 실제로 4메가는 더큼.)
대략, 128메가면
 128/4=32
 int 3천2백만개 저장가능.

*/