//gpt한테 해결방법 물어봄.
//점화식 확인함. -> 나중에 다시 풀어보기?.
//코드 96줄 방식 기억하기
/*
!!!!!!!!!!!!!!!!!!!!중요!!!!!!!!!!!!!!!!!!!!
dp문제 여러개 풀어보니까 이 문제, 굉장히 중요한 문제임.

1) 
기존 dp는 o(n제곱)문제면, 인덱스 i에서 j만큼 모두 탐색한 후,
i+1로 가게되면 
다시 i에는 영향을 미치지 않는 반면(즉, d[i]의 값을 한번 정하면 웬만하면 바꾸지않고, 한번정해지면끝인반면)
이 문제는
계속 이전의 d[i]값들이 업데이트 되는 방식임.

2)즉, 
기존 문제는 index를 기준으로 j를 순회했다면
이 문제는 j를 차레로 채우며, 각 j에서 i를 순회하고. 
다시 이전 j로 돌아가지 않는방식임.

=>문제를 잘 살펴보고 적용해야하며, 코인1과 같은 문제의 경우 이런방식으로 밖엔 풀 수없음.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*/

#include <iostream>
using namespace std;

int n,k;
int a[101], d[10001]; //d[i]=가치의 합을 i원 으로 맞추는 경우의 수.

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>k;

    for(int i=1; i<=n; i++) cin>>a[i];

    d[0]=1;
    for(int i=1; i<=n; i++){
        int coin=a[i];
        for(int j=coin; j<=k; j++)
            d[j]+=d[j-coin];
    }

    cout<<d[k];

}

/* [gpt한테 물어봐서 얻은 답변]

이 문제는 동전의 합으로 특정 금액을 만드는 경우의 수를 구하는 **동전 거스름돈 문제(거스름돈 문제의 변형)**이며, **DP(동적 계획법, Dynamic Programming)**을 사용하여 해결할 수 있어.


ㅁ 해결 전략

DP 배열 정의:
dp[i]를 **"i원을 만드는 방법의 수"**라고 정의.
dp[0] = 1 (0원을 만드는 방법은 아무것도 사용하지 않는 한 가지 방법)

점화식 유도:
각 동전을 사용하여 누적된 경우의 수를 갱신하는 방식 사용.
동전 가치 coin을 이용해 dp[j] += dp[j - coin]을 수행
즉, j원을 만들 때 coin을 사용한 경우를 추가

순회 방식 (배낭 문제의 변형):
중복 사용 가능하므로 "배낭 문제(Unbounded Knapsack)" 방식을 활용
동전을 하나씩 고려하면서 DP 배열을 업데이트 (이전 결과를 기반으로 갱신)



ㅁ 예제 풀이 과정
입력:
n = 3, k = 10
동전 종류: [1, 2, 5]

> DP 테이블 갱신 과정:

-> 1원을 사용할 때:
dp[1] += dp[1-1], dp[2] += dp[2-1], ..., dp[10] += dp[10-1]

dp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

-> 2원을 사용할 때:
dp[2] += dp[2-2], dp[3] += dp[3-2], ..., dp[10] += dp[10-2]

dp = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6]

-> 5원을 사용할 때:
dp[5] += dp[5-5], dp[6] += dp[6-5], ..., dp[10] += dp[10-5]


dp = [1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 10]

최종 답:
dp[10] = 10
즉, 10원을 만들 수 있는 방법의 수는 10가지.

이제 코드를 직접 작성해 보면서 위의 흐름을 따라가 보는 걸 추천해! 😊

그렇게 만들어진 코드는
시간복잡도는 o(n*k)임.
*/


/* [이 문제를 통해 가져가야 하는 교훈/발상 등]
역시, dp문제를 풀때는 작은 수, 처음 수 부터 차근차근 차례대로 생각하는 것이 좋음.

근데, 또 발상의 전환으로 한번에, 1/2/5원을 다 고려하는게 아니라
!!!! 1원만 고려해서 10원(목표치인 k원)까지
     2원만 //
     5원만 //
     이런식으로 계속 점층적으로 더해나가는것도 가능하다는 걸 기억하고 외우고 인지하기.

즉, 원래는 
1) o(n)방식
2) o(n^2)방식 -> 각 인덱스 i지점에서 일정범위인 j를 비교하는 방식 이었다면
3) 애는 o(n*m)방식으로 -> (2)와 비슷하긴 하나, 1원,2원...5원...을 따로 생각해서
  >>>!!d[i]를 계속 더해나간다는 점에서 차이가 있음.<<< (원래는 max함수를 통해서 업데이트하기만 했는데.)

  (3)의 방식을 기억하기!!!

[여담, 정답코드의 방식이 gpt가 알려준 것과 완전히 동일한 걸로 보아, 아마 이사람도 어디서 참고했을 확률 높음..]
*/





/*
gpt한테 묻기 전엔

    for(int i=1; i<=k; i++){
        for(int j=1; j<i; j++){
            d[i]=d[i-j]*d[j];
            
        }
    }
다음과 같이, 예를들어 i=30이라면, j=4일땐, j[26]*d[4]로 해서 
26을 만드는 경우의수(앞자리)*4를 만드는 경우의 수(뒷자리)로 하려고했음.
근데 아무리 생각해도 이런식의 방법으로는 
"순서를 고려하지 않는 조합형태"의 경우의수 를 만족시킬 수 없음.
(
ex, 
i=8이고, j=4여서 
d[4], d[4]를 연산해야하는경우 만약 d[4]안에있는건, 일단 조합 경우의수를 만족한다고 하더라도.(동전가치는 1,2짜리만 있다고가정)
(112) (22)와 (22) (112)가 동일한데 이걸 걸러내지못함.
또, d[3], d[5]라고 해도
(12) (1112) 와 (111) (221)을 걸러내지 못함. 
즉 =>이방식으로는 절대 조합에서의 경우의수를 구해내지 못함.
)

[곱셈 대신 덧셈하면 되나? 싶었는데 생각해보니 이건 그냥, 말이안됨.]

그래서 고민하다가 그냥 gpt 물어봄.

*/