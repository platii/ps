//암호코드 문제
//A=1 ~ Z=26
#include <iostream>
using namespace std;

string s;
int d[5001]; // d[i]=입력받은 문자열의 i번째 인덱스 까지 암호의 해석이 나올 수있는 경우의수를 1000000으로 나눈 나머지
int mod=1000000;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>s;
    //초기값 대입
    if(s[0]-'0'==0) {//맨 처음 값 0이면 invalid, 0출력
        cout<<0;
        return 0;
    }
    else d[0]=1;
    bool pre_two_valid=false;
    if(s.length()>=2){
        d[1]=1; //d[1]=d[0]%mod; s[0]위치의 값이 0이아닐때만 이 코드를 실행했을 것이므로. d[0]=1일 것. 
        int Two_digit=(s[0]-'0')*10+(s[1]-'0'); 
        if(s[1]-'0'==0){ //s[i]가 0인데, (또한, 앞자리가 0이아님을 내포함.)
            if(Two_digit>=1 && Two_digit<=26) int nothing; //아무것도하지않음.
            else {//s[i]가 0인데 범위안에 들지않으면 30, 40과 같은 invalid 이므로 0출력
                cout<<0;
                return 0;
            }
        }
        else if(Two_digit>=1 && Two_digit<=26) {
            d[1]++;
            pre_two_valid=true;
        }
    }
    //d배열 채우기
    for(int i=2; i<s.length(); i++){
        d[i]=d[i-1]%mod; //d[i]의 초기값은 0임. i-1번째 값을 이어받음.
        int Two_digit=(s[i-1]-'0')*10+(s[i]-'0'); //char를 int로 변환
        if(s[i]-'0'==0){
            if(Two_digit>=1 && Two_digit<=26){
                //이때, j=i-1이라고 하면 d[j]에서 (j-1,j)두자리수 값이 유효했다면 d[i]는 d[j]-d[j-2]한 값임.
                if(pre_two_valid) {
                    if(i==2) d[2]=d[1]-1;
                    else d[i]=d[i-1]-d[i-3];
                }
                pre_two_valid=true;
            }
            else{//두번연속 0인 -> 0이거나, 30,40,50...90같은 invalid임. -> 0출력
                cout<<0;
                return 0;
            }
        }
        else if(Two_digit>=1 && Two_digit<=26 && (s[i-1]-'0')!=0) {//만약 앞이 0이라면, 두자리수는 성립하지 않음, why? 0은 0앞에 값과 결합해서만 사용가능하므로.
            d[i]=(d[i]+d[i-2])%mod;
            pre_two_valid=true;
        }
        else pre_two_valid=false; //s[i]가 0이 아니면서, (i-1,i)두자리수가 유효하지 않을때 
    }

    cout<<d[s.length()-1];
}

//mod의 덧셈 범칙 => (a+b)mod x = (a mod x + b mod x) mod x

/* [풀이]
점화식 ->
i한자리 에 대해 valid한 경우, d[i]+=d[i-1] 
(i-1, i)두자리에 대해 valid한경우 d[i]+=d[i-2]

[2*n문제와 거의 동일한 발상임, i번째 인덱스가 유효하다면 d[i-1]의 경우의수를 그대로 가지고
i-1까지 연장한 (i-1,i)가 유요하다면 d[i-2]경우의수 값을 추가로 가짐.
]
->다만 숫자 0과, 유효함을 체크하는데 있어서
반례등이 애를 먹이는 문제
*/

//실수 : 한자리수인데 0이면 문자에 해당 안됨.
//두자리수체크에서, 05 처럼 십의자리수가 0이면 새로운 경우의 수가 아닌건 알고 있었음.

/*
몇개 시도 했는데, 다 안됨.
"암호가 잘못되어 해석할 수 없는 경우 0을 출력하시오"라는데
아니 암호가 잘못된 경우가 정확히 어떤경우인지에 대한 설명이 없음;

*/


/* [백준의 질문글들 에서 반례 제공한거 보고 해결.]
->반례 찾기가 매우 매우 매우 까다로운 문제.

///////////////아래는 수정전 코드 
//암호코드 문제
//A=1 ~ Z=26
#include <iostream>
using namespace std;

string s;
int d[5001]; // d[i]=입력받은 문자열의 i번째 인덱스 까지 암호의 해석이 나올 수있는 경우의수를 1000000으로 나눈 나머지
int mod=1000000;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>s;
    if(s[0]-'0'==0) {
        cout<<0;
        return 0;
    }
    //초기값 대입
    if(s[0]-'0') d[0]=1;
    if(s.length()>=2){
        if(s[1]-'0' && d[0] == 0) d[1]=1;
        else d[1]+=d[0]%mod;

        int Two_digit=(s[0]-'0')*10+(s[1]-'0'); 
        if(Two_digit>=1 && Two_digit<=26 && (s[0]-'0')!=0) d[1]++;
    }
    //d배열 채우기
    for(int i=2; i<s.length(); i++){
        if(s[i]-'0'!=0 && d[i-1]==0) d[i]=1;
        else d[i]=d[i-1]%mod; //d[i]의 초기값은 0임.

        int Two_digit=(s[i-1]-'0')*10+(s[i]-'0'); //char를 int로 변환
        if(Two_digit>=1 && Two_digit<=26 && (s[i-1]-'0')!=0) d[i]=(d[i]+d[i-2])%mod;
    }

    cout<<d[s.length()-1];
}
///여기까지가 기존 코드였음.

반례 
입력:100
답0(올바르지 않으므로)
->출력:2

입력:20326
답:2
->출력:4
(20이면, 그냥 20임. 203이라고해서, 2와3으로 나뉘지 않음 무조건 20하고 3임이걸 잘못해석한거였음.)

=>즉 문제를 잘못해석한것.
00이 두개붙으면 무조건 틀린거고.
10,20이렇게 나오면 무조건 10,20 고정인것임.
30,40....90은 잘못된것임.

반례
입력 : 210
답:1
->출력:2
==>21까진 경우의수 2였다가 210이 되면 ,10이 고정되므로 경우의수는 1이되어야함.
즉 i번째 인덱스에서 s[i]가 0이고, (i-1,i)두자리수가 valid로 확정되었다면[즉 10 or 20이라면]

이전인덱스를 j로가정하면 (또, j번째 인덱스 숫자갸 0이 아니라면)
j에서 d[j]=d[j-1]을 하고, 마찬가지로 (j-1,j) 두자리수가 유효했다면 d[j-2]도 더해줬을것임.
여기서, d[j]=d[j-1]을 한것만 두고.
d[j-2]를 더한건 빼줘야함.
예를들어 j가 1이라면 
(j,i)가 10이되고, 10자체가 하나의 유효한 암호글자(변환되는 알파벳)가 되었으므로,
j-1과 j를 결합해서 암호글자(변환되는 알파벳으로)로 쓰면안됨
j가 1일때나,
j,i로 10일때나 d[j]=d[j-1]로 받는건 동일하므로 이건 그냥 두면됨.
따라서 이경우, 정리하면. 
d[j]에서 (j-1, j)두자리 수가 유효했는지 체크하고
유효했다면 d[j]에서 d[j-2]를 빼준 값이 d[i]가 됨.

즉 d[i]=d[j]-d[j-2]가 되는 것.
[정정] d[j]값 자체는 바꾸면안됨. 왜냐? 
d[i]테이블 정의 자체가 index를 i까지만 봤을 때니까 j까지본 그 당시에는 그 값이 맞는 것임.

이전인덱스 j=i-1이므로.

그에맞게 적용.

 */