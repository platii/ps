#include<iostream>
using namespace std;

int n;
int d[10001];
//d[i]=민규가 카드 i개를 갖기 위해 지불해야 하는 금액의 최대값.

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    for(int i=1; i<=n; i++){
        cin>>d[i];
        /* 정답코드 보고 위 코드 한줄로 개선 (a[]배열을 삭제함. why? 이후 코드에서 a[i]배열이 필요없고, d[i]값을 직접 쓰면되기 때문.)
        아래처럼 할필요 없음.
        cin>>a[i];
        d[i]=a[i]; //d[i]의 초기값은 a[i](우선 i개를 팩하나로 한번에 채우는 가격 a[i]를 초기값으로 설정)
        */
    }
    d[0]=0;
    for(int i=1; i<=n; i++){
        for(int j=1; j<=i/2; j++){
            d[i]=max(d[i-j]+d[j], d[i]);
        }
    }
    cout<<d[n];
}


/* 풀이

    i=1, d[1]=1개를 채울 때 가격의 최대값, -> i=1로만 채운거.
    i=2, d[2]=2개를 채울 때 가격의 최대값, 즉 1개카드팩과 2개 카드팩으로만 이루어질 수 있다.
    i=3, //~ 동일하게 i=3, d[3]=3개 카드팩, (2개카드팩, 1개카드팩), (1개카드팩을 3개샀을때)의 경우의 수로 나눌 수 있음.
                이 경우의 수들을 모두 대소 비교하면 됨.

                ...

    i=n, => d[i-0]+d[i-i]<초기값인 a[i]>, d[i-1]+d[1], [i-2]+d[2], d[i-3]+d[3]......d[i-j]+d[j]을 i-j>0일때까지 계속. 즉 j=1~j=i-1까지
            =>매 인덱스에서 i번 진행하게되므로, o(n^2) ->1000*1000->1백만번 연산이므로 1초안에 가능.


    !!!!!!!!!!!->업그레이드 정정!!!!!!!!!!!
    j의 for문에서
    for(int j=1; j<i; j++){로 뒀었지만

    어짜피, i의 절반이 되는 지점에서 그 이후는 또 다시 반복되므로
    결국 j=i/2까지만 for문을 돌려도 됨. 이는 i가 홀수여도 성립함.
    ex) i=50일때, 49/1, 48/2, ... 26/24, 25/25 !! 24/26 <- 이 지점부터 이전에 했던 계산을 반복하게 됨.
    즉 절반까지만 for문을 계산해도 된다.

    ->T(n^2)에서 => T((n/2)*n)으로 개선!

    //정답코드와 비교 ->(a배열을 안썻다는 것 빼곤)동일함. 오히려 직접푼 코드가 i/2까지만 j를 돌려 시간복잡도 감소함.
*/