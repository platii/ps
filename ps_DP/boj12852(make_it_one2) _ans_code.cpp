//**정답코드
//정답코드는 경로를 추적하는 방식으로, 직접 추적하는 방식이 아닌
//이전의 위치, 즉 경로를 저장하는 배열을 따로 만들어서 해결하였음.
#include <iostream>
#include <algorithm>
using namespace std;

int d[1000001];
int pre[1000001]; //이전의 위치 저장.

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin>>n;
    d[1]=0;
    pre[1]=0; //어짜피 pre[1]은 참조되는 값아니니 신경쓰지 않아도 되긴 함.
    for(int i=2; i<=n; i++){
        d[i]=d[i-1]+1;
        pre[i]=i-1;
        if(i%2==0 && d[i/2]<d[i]) {
            d[i]=d[i/2]+1;
            pre[i]=i/2;
        }
        if(i%3==0 && d[i/3]<d[i]) {
            d[i]=d[i/3]+1;
            pre[i]=i/3;
        }
    }
    cout<<d[n]<<'\n';

    //경로 출력
    int cur=n; //cur는 현재 위치
    while(cur!=0){ 
        cout<<cur<<' ';
        cur=pre[cur];
    }
}

/* 직접푼코드와 차이.

- 직접 푼 코드,
  경로 저장 배열을 만들지 않고, distance배열만 채운 후에 
  마지막에 경로를 다시 계산해서 출력함.

- 정답 코드
  경로 저장배열을 만들어서 distance 배열을 채우는 과정에서
  pre배열 채우는 과정도 동반함.

>>시간복잡도의 차이?
우선 시간복잡도는 o(n+d[n])으로 동일함,
그러나, 백준 풀이 결과 직접푼 코드가 4ms, 정답코드가 8ms였음.
이는 직접푼 코드는 마지막에만 경로를 계산하고.
정답코드는 매 과정에서 이전 값을 찾아주는 과정을 거쳐서 그런 것으로 보임.

그래서 만약, 경로를 찾는 횟수가 많아질 수록 미리 pre배열을 만들어 두는 것이 더 효율적일 것으로 추측됨.
그러나, 지금 문제처럼 일회성으로 끝나는 경우, 그냥 distance배열만 만들어두고, 마지막에 경로를 계산해서 출력해주는 것이 효율적으로 보임.
(코드의 길이나 가독성면에서는 서로 비슷하니, 경우에 따라 맞는 방법을 차용하는 것이 좋음.)

=> 따라서, 문제가 복잡해 질수록 
    지시 입력이 여러개인 경우가 많은
    백준 문제 스타일을 고려했을 때
    pre배열 방식을 차용하는 것이 좋아보임.


*/