//정답코드는 안보고_gpt에 힌트 물어봄.
//발상 gpt보고 품. 점화식도 gpt 에서 알려준대로 작성함.
#include <iostream>
#include <algorithm>
using namespace std;

int n;
int t[20], p[20]; //0~14면 15, 0~1~15라고 하더라도 16까지만 있으면 되지만, 그냥 넉넉하게 20 줌.
int d[20]; // (gpt참고) _ d[i]=i번째 일부터 퇴사일 까지 백준이가 얻을 수 있는 최대 수익.

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    for(int i=1; i<=n; i++){
        cin>>t[i];
        cin>>p[i];
    }
    
    d[n+1]=0; //퇴사일을 넘길 수는 없기때문. (퇴사일은 n+1일)[퇴사일은 일 불가]

    for(int i=n; i>=1; i--){
        if(i+t[i] <= n+1){ //그 날 상담을 할 경우(단, i+t[i] <= n+1일때만)
            d[i]=max(d[i+t[i]]+p[i], d[i+1]);
            /* 위가 정답코드 보고 수정한 코드
            d[i]=p[i]+d[i+t[i]];
            for(int j=1; j<=n-i; j++) d[i]=max(d[i], d[i+j]);
            */
        }
        else d[i]=d[i+1]; //상담을 안 할 경우
    }
    cout<<*max_element(d+1, d+n+1);
}

/*
작성 방법.

// gpt답변
발상 힌트
역방향 접근 (Backward)

마지막 날부터 거꾸로 생각하면, 오늘 상담을 선택했을 때와 선택하지 않았을 때의 이익을 비교하는 방식으로 문제를 단순화할 수 있습니다.
두 가지 선택

오늘의 상담을 한다면, 상담이 끝난 이후의 최대 이익을 더합니다. 하지만, 이때 상담이 끝나는 날짜가 퇴사일을 넘어가면 무효 처리합니다.
오늘의 상담을 하지 않는다면, 다음 날부터의 최대 이익을 가져옵니다.
점화식 설계

dp[i]를 i일부터 퇴사일까지 얻을 수 있는 최대 수익이라고 정의합니다.
점화식:
상담을 한다면: dp[i] = Pi + dp[i + Ti] (단, i + Ti <= N + 1인 경우)
상담을 하지 않으면: dp[i] = dp[i + 1]
기저 조건

퇴사일 이후에는 더 이상 상담할 수 없으므로, dp[N+1] = 0입니다
//

// 이게 gpt가 준대로 쓴 발상.

    d[n+1]=0; //퇴사일을 넘길 수는 없기때문. (퇴사일은 n+1일)[퇴사일은 일 불가]

    for(int i=n; i>=1; i--){
        if(i+t[i] <= n+1) d[i]=p[i]+d[i+t[i]];
        else d[i]=d[i+1];
    }

    cout<<*max_element(d+1, d+n+1);
}

//

그러나,
//
10
5 50
4 40
3 30
2 20
1 10
1 10
2 20
3 30
4 40
5 50
//
해당 입력에서 90이 나와야 하는데 80이나옴.
이유는, 6번째인 1 10에서 2 20으로 넘어간 후, 2 20은 4 40으로 넘어가기 때문, 근데 그냥 2 20을 스킵하고 
3 30으로 가는게 더 큰 값이 나올 수 있는데, 해당 코드에선 이게 불가능

(응용해서 직접 푼 방식)
-> o(n^2)방식을 사용함. [연속합, 증가하는 부분수열 문제에서 사용한 방식과 비슷한 방식을 사용]
[i+t[i]로 넘어갈 수 있다고 할지라도, i와 i+t[i]사이에있는 지점이나 혹은 i+t[i]지점을 무시하고 다음 지점으로 넘어 갔을 때
총합이 더 커질 수도 있으므로, 결국 i부터 n까지 모든 지점을 고려해야함]
[아래는 그 방법의 예시]

위의 예에서, 6번째날인, 1 10의 경우, 
6번째날에 상담을 한경우를 d[i]로 설정하고 이후, 
1 10의 다음인 2 20(7번째 날)부터 5 50(10번째날)끝 까지 max값을 d[i]에 max값인 걸 더함.
[즉 해당날에 상담을 한 경우와 상담을 안한경우 + 쭉 상담을 안했을때 n일까지 비교한 최대값. (상담을 안하면 어디까지 안해야 최대값이 되는지)]
*/

/* 기억해야할 포인트.

- 배열을 뒤에서부터 채우는 발상
- //이미 알았던(n^2)의 발상//

*/

/*
정답코드 체크.

-> 굳이 저렇게 o(n^2)으로 안해도 됨.
max(d[i+t[i]]+p[i], d[i+1])로 두면 됨.
d[i+1]이 이미, i+2인날 일은 안했을 때 혹은 헀을때 최대값, i+3인날이 .., i+4 인... 
날의 값들을 내포하고있기 때문.

간단히, d[i+1]의 값이 이미 이전과정을 포함하고 있기 때문임. 즉, 이전과정을 포함해서 얻어진 최대인 d[i+1]값임.
(코드보고 이해하기)

1)배열을 뒤에서부터 채우는 발상
2)뒤에서부터 한칸 씩 점진적으로 max로 비교하는 발상
을 기억해두기

*/

/* 정답코드-별해 (앞에서부터 채워나가는 방법)

/////////
  for(int i = 1; i <= n; ++i){
    // d[i]값 확정
    d[i] = max(d[i], d[i-1]);

    // i번째 날 상담을 할 경우 i+t[i]-1은 상담이 종료되는 날
    if(i + t[i]-1 <= n) // 상담이 n일 이전에 종료될 경우
      d[i + t[i]] = max(d[i + t[i]], d[i] + p[i]); // d[i+t[i]] 갱신
  } 
  cout << max(d[n], d[n+1]);
}

-주석-
테이블을 채워나가는 방식이 조금 낯설 수 있으나,
d[i] = max(d[i], d[i-1]); 를 한 순간 d[i]값이 확정되고 이후
d[i+t[i]]를 갱신한다고 이해할 수 있다.
-   -
//////////

해당 파일의 코드와는 다르게
처음부터 채워나가는 방식임.
d[i]=i-1번째 날까지 상담을 했을 때 벌 수 있는 최대 금액 으로 두고

d[i]=max(d[i-1],d[i])를 통해 d[i]를 확정지음

이후, 상담일을 넘기지 않는다면,
d[i+t[i]] = max(d[i + t[i]], d[i] + p[i]) 를 통해 갱신함.
(즉, 기존에 여러 곳에서 점프 뛰어와서 저장되어있던 d[i]+p[i]들이 계속 비교되어 가장 큰 값만 남게 되는 것.)

이후, max(d[i-1],d[i])를 통해 마지막으로 이전값과 비교하고, i를 넘겨 i+1번째를 비교하게 되면
d[i]는 확정된채로 d[i+1]을 비교하러 가는 것.

*/