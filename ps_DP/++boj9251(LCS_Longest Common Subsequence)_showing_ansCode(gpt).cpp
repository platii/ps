//gpt한테 힌트 물어봄.

#include <iostream>

using namespace std;

int d[1001][1001];
/*d[i][j]=첫 번째 문자열의 앞에서 i번째까지와 두 번째 문자열의 앞에서 
            j번째까지를 사용했을 때의 최장 공통 부분 수열(LCS)의 길이
*/
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    string a, b; //첫,두번째 문자열을 받을 char배열(string)
    cin>>a>>b;
    int al=a.length();
    int bl=b.length();
    for(int i=1; i<=al; i++){
        for(int j=1; j<=bl; j++){
            //i번째 문자와 j번째 문자가 같은 경우.
            if(a[i-1]==b[j-1]) d[i][j]=d[i-1][j-1]+1; //string의 인덱스는 0부터 시작하므로, for문에서의 인덱스와 맞춰주기 위해 -1씩함.
            //다른 경우
            else d[i][j]=max(d[i-1][j], d[i][j-1]);
        }
    }
    cout<<d[al][bl];
}

/*
gpt한테 받은 힌트

(1)
이 문제는 **DP(Dynamic Programming)**를 활용하는 전형적인 유형입니다. 힌트를 드리자면:

이 문제의 시간 복잡도는 O(n × m) 정도로 풀 수 있어요. (n과 m은 각각 두 문자열의 길이입니다.)
두 문자열의 각각의 문자를 비교하면서, 부분적으로 결과를 쌓아가는 방식으로 접근해야 해요.
이전까지 계산된 결과를 기반으로 다음 결과를 계산하므로, 2차원 테이블을 활용해 누적된 최적의 결과를 저장하면서 풀게 됩니다.
작은 부분 문제를 먼저 풀고, 그것을 확장해 전체 문제를 푸는 방식이에요.
힌트를 한 마디로 요약하자면, "두 문자를 비교하고, 이전의 결과를 참고하며 현재의 최적해를 갱신하는 방법을 찾아보세요!" 😊


(2) 질문 : 힌트를 좀 더줘
좋아요, 힌트를 조금 더 드릴게요! 😊

LCS의 핵심 아이디어는 두 문자열의 문자 비교와 "선택지"를 가지는 거예요.

두 문자가 같으면 **"공통 부분 수열에 포함된다"**고 보고 진행합니다.
두 문자가 다르면, **"하나를 제외하거나, 다른 하나를 제외했을 때 더 긴 부분 수열"**을 선택합니다.
따라서, 테이블에 저장되는 값은 **"현재까지의 최장 공통 부분 수열의 길이"**입니다.

마지막으로, 테이블의 값을 업데이트할 때는 이전 단계의 결과를 활용하여 "최적의 선택"을 합니다.

이 힌트를 통해 문제의 구조를 좀 더 명확히 이해해보세요! 🚀


(3) 질문 : 테이블 정의를 알려줘
좋아요! 테이블 정의를 힌트 형태로 알려드릴게요. 😊

테이블 정의

dp[i][j]는 첫 번째 문자열의 앞에서 i번째까지와 두 번째 문자열의 앞에서 j번째까지를 사용했을 때의 최장 공통 부분 수열(LCS)의 길이를 나타냅니다.
예시

문자열 A = "ACAYKP", B = "CAPCAK"이라고 할 때:
dp[3][4]는 A의 앞 3글자 "ACA"와 B의 앞 4글자 "CAPC"를 사용했을 때의 LCS 길이를 의미합니다.
이제 테이블을 어떻게 채워야 할지 고민해보세요! 🚀


(4) 질문 : 아 모르곘다
ChatGPT의 말: >>>사실상 답<<<
ChatGPT
괜찮아요! 차근차근 함께 생각해봅시다. 😊

테이블 정의는 이미 했으니, 테이블을 채우는 방법에 대해 더 구체적인 힌트를 드릴게요.

테이블 초기화
dp[0][j]와 dp[i][0]
첫 번째 문자열이나 두 번째 문자열 중 하나라도 길이가 0이라면, 공통 부분 수열도 당연히 길이가 0입니다.
즉, 테이블의 첫 행(dp[0][j])과 첫 열(dp[i][0])은 모두 0으로 초기화됩니다.
점화식
이제 테이블을 채워야 하는데, 두 문자열의 현재 위치를 비교하며 다음 규칙을 따릅니다:

문자가 같을 때

A의 i번째 문자와 B의 j번째 문자가 같다면,
dp[i][j] = dp[i-1][j-1] + 1
이전 위치까지의 LCS에 현재 문자를 추가할 수 있으므로, 길이를 1 증가시킵니다.
문자가 다를 때

A의 i번째 문자와 B의 j번째 문자가 다르다면,
dp[i][j] = max(dp[i-1][j], dp[i][j-1])
두 선택지 중 더 큰 값을 가져옵니다:
(1) 첫 번째 문자열에서 한 글자를 제외하거나
(2) 두 번째 문자열에서 한 글자를 제외했을 때의 최대 LCS 값.

최종 결과
테이블의 **마지막 값 dp[len(A)][len(B)]**이 바로 두 문자열의 LCS 길이가 됩니다.
힌트 시뮬레이션 (예시)
A = "ACAYKP", B = "CAPCAK"인 경우,

A[1] == B[1] → 공통 문자라면 값을 증가.
A[2] != B[3] → 공통 문자가 아니라면 이전 값을 참고해 최대값 선택.

*/


//정답코드?->그냥 본문코드랑동일함.

/* 교훈, 넉두리

점화식을 알기전까진 힌트를 줘도 코드를 못짰는데,
점화식 주니까 바로 이해할 수 있었음.
그냥 그대로 적고, 경계점 같은거 고려해서 코드 수정하니 통과.
근데? 내용적힌트 다줘도 점화식 주기 전까지 생각하지 못했음.

또 힌트를 주기 전까지, 힌트발상(맨처음 힌트 제외)을 생각 못했음.
->그냥, 보통1시간~최대2시간 고민하고 안되면 바로 gpt한테 힌트~점화식.정답까지 요청하자.
[내가 생각한 방식은 
2차원 배열까진 생각했음.
근데 이제 d[i][j]=1문자열의 i번째 인덱스, 2문자열의 j번째 인덱스에서 시작했을 때 lcs의 최대값
으로 두고,
i,j를 늘려갈때마다 이전의 d[i][j]를 늘려가는, coin_1(동전1 문제)의 문제 풀이 방식을 생각했음.
근데 이렇게하면 i, j크기가 늘어날 수록 경우의수가 늘어나서 사실상
백트래킹 방식을 쓰는게 아니면 불가능하고
ACAYKP
CAPCAK   를 예로들면 맨처음 A매칭하고, 그다음 C를매칭하는데, 이떄 C가 A뒤에있는 경우, A앞에서 시작하는 경우로 나뉨....~~이렇게 계속 뒤 문자열도 경우의수가 늘어나서 이런식으로 그냥 풀수가 없었음.
이전의 dp값을 사용하지않아 dp 알고리즘을 쓰는 의미가 없어졌음. 

그래서 힌트 물어봐서 그냥 테이블까지 물어봤음->생각했던것과 아에 다른 방식이었음.
-> 근데 도저히 점화식이 생각 안나서 그냥 물어봄.->사실상 답 물어본거랑 동일.
]

일단, 알아두어야할 방식은.
->근데 사실 방식은 이전의 했던 방식들이랑 동일함.(이전의 값에서 점층적으로 쌓아올리기, MAX사용하기)
그냥
(1)테이블 정의, (2)점화식 찾기
이걸 못하면 의미없는거였음. 방식이랄 것도 딱히 없음.

그나마 교훈이라고 할만한 건 DP는 역시, 항상 이전의 값에서 약간만 작업해서(가령 +1작업, MAX작업등)
그 다음값을 업데이트 할수 있도록 해야지
내가 처음생각해서 실패한 발상처럼 너무 복잡하게 이뤄지면 안된다는걸 기억하기.

*/