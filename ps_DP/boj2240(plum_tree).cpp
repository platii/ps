#include <iostream>
#include <algorithm>
using namespace std;

int t,w;
int d[1001][31][3]; 
//d[i][j][k]=i번째 초에서 j만큼 이동횟수가 남았고, 현재위치 k일때, 그때까지 자두를 먹은 개수

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>t>>w;
    int tree_pos; //자두가 떨어지는 나무의 위치
    d[1][w][1]=0; //자두의 초기위치는 1
    for(int i=1; i<=t; i++){ //자두를 먹으려고 이동.
        cin>>tree_pos;
        for(int j=w; j>w-i && j>=0; j--){
            if(tree_pos==1){ //현재위치가 tree_pos와 일치하면 자두o
                if(j-1>=0) d[i][j-1][1]=max(d[i][j-1][1], d[i-1][j][2]+1); //이전위치 2에서 자두를 먹으려고 현재위치1로 이동했을 때.
                d[i][j][1]=max(d[i][j][1], d[i-1][j][1]+1); //이전위치 1, 현재위치1, 이동x, 자두o
                if(j-1>=0) d[i][j-1][2]=max(d[i][j-1][2] ,d[i-1][j][1]); //이전위치 1, 현재위치2, 이동 o, 자두x
                d[i][j][2]=max(d[i][j][2] ,d[i-1][j][2]); //이전위치 2, 현재위치2, 이동x, 자두x
            }
            else{ //tree_pos==2일때
                if(j-1>=0) d[i][j-1][1]=max(d[i][j-1][1] ,d[i-1][j][2]); //이전위치 2, 현재위치 1, 이동 o, 자두x
                d[i][j][1]=max(d[i][j][1] ,d[i-1][j][1]); //이전위치 1, 현재위치1, 이동 x, 자두x
                if(j-1>=0) d[i][j-1][2]=max(d[i][j-1][2] ,d[i-1][j][1]+1); //이전위치 1, 현재위치2, 이동o, 자두o
                if(i!=1) d[i][j][2]=max(d[i][j][2] ,d[i-1][j][2]+1); //이전위치 2, 현재위치2, 이동x, 자두o
                //i=1일땐 초기위치 2이므로 제자리에서 자두를 먹지못함. 그래서 0으로 유지해아함. 이동 한경우만 자두를 먹은것이되어야함.
            }//j>=0, if(j-1>=0), max추가
        }
    }


    /* 수정이전의 코드(자두를 먹고나서 이동)
    for(int i=1; i<=t; i++){
        cin>>tree_pos;
        for(int j=w; j>w-i && j>=0; j--){
            if(tree_pos==1){ //이전위치가 tree_pos와 일치하면 자두o
                if(j-1>=0) d[i][j-1][2]=max(d[i][j-1][2], d[i-1][j][1]+1); //이전위치 1에 위치하여, 자두를 먹고 위치를 2로 바꾸었을 때
                d[i][j][1]=max(d[i][j][1], d[i-1][j][1]+1); //이전위치 1에 위치하여, 자두를 먹고 위치를 바꾸지 않았을 때(이동x)
                if(j-1>=0) d[i][j-1][1]=max(d[i][j-1][1] ,d[i-1][j][2]); //이전위치 2, 자두x, 이동 o
                d[i][j][2]=max(d[i][j][2] ,d[i-1][j][2]); //이전위치 2, 자두x, 이동 x
            }
            else{ //tree_pos==2일때
                if(j-1>=0) d[i][j-1][2]=max(d[i][j-1][2] ,d[i-1][j][1]); //이전위치 1, 자두x, 이동 o
                d[i][j][1]=max(d[i][j][1] ,d[i-1][j][1]); //이전위치 1, 자두x, 이동 x
                if(j-1>=0) d[i][j-1][1]=max(d[i][j-1][1] ,d[i-1][j][2]+1); //이전위치 2, 자두o, 이동 o
                d[i][j][2]=max(d[i][j][2] ,d[i-1][j][2]+1); //이전위치 2, 자두o, 이동 x
            }//j>=0, if(j-1>=0), max추가
        }
    }
    */
    /*
    //d배열 테스트
    cout<<"테스트"<<'\n';;
    for(int i=0; i<=t; i++){
        cout<<"   i :"<<i<<'\n';
        cout<<"    ___"<<'\n';
        for(int j=0; j<=w; j++){
            cout<<"j:"<<j<<"|";
            for(int k=1; k<=2; k++){
                cout<<d[i][j][k]<<' ';
            }
            cout<<'\n';
        }
        cout<<'\n'<<'\n';
    }
    //
    */

    int ans=0;
    for(int i=0; i<=w; i++) ans=max(ans, *max_element(d[t][i], d[t][i]+3)); //t초, 현재위치 1~2일때 먹은 자두개수를 모든w에대해 비교
    cout<<ans; 
}

/*
1. 테이블 정의
d[i][j][k]=i번째 초에서 j만큼 이동횟수가 남았고, 현재위치 k일때, 그때까지 자두를 먹은 개수

2. 점화식 찾기
for(int i=1; i<=t; i++){
    cin>>tree_pos;
    for(int j=w; j>=1; j--){
        if(tree_pos==1){
            d[i][j-1][2]=d[i-1][j][1]+1; //이전위치 1에 위치하여, 자두를 먹고 위치를 2로 바꾸었을 때
            d[i][j][1]=d[i-1][j][1]+1; //이전위치 1에 위치하여, 자두를 먹고 위치를 바꾸지 않았을 때(이동x)
            d[i][j-1][1]=d[i-1][j][2]; //이전위치 2, 자두x, 이동 o
            d[i][j][2]=d[i-1][j][2]; //이전위치 2, 자두x, 이동 x
        }
        else{ //tree_pos==2일때
            d[i][j-1][2]=d[i-1][j][1]; //이전위치 1, 자두x, 이동 o
            d[i][j][1]=d[i-1][j][1]; //이전위치 1, 자두x, 이동 x
            d[i][j-1][1]=d[i-1][j][2]+1; //이전위치 2, 자두o, 이동 o
            d[i][j][2]=d[i-1][j][2]+1; //이전위치 2, 자두o, 이동 x           
        }
    }
}
//위는 수정 이전의 풀이
자두를 먹으려고 이동하는게 아닌, 자두를 먹고나서 이동하는 이상한 점화식이됨.
예를들어 i=1일때, 
tree_pos가 1이고
j=w이면, i=1에서의 테이블은
0 0 j=1
0 0 j=2
~~  ~
0 1 j=w-1
1 0 j=w
이 되게 됨. 이러면, 0 1 위치에서의 1은 i=1인 순간 이전위치 1에서 자두를 먹고, 2로 이동한 상태가 됨.
i=1인순간 자두를 먹으려고 이동하게끔 설정하면 테이블은
1 0 j=w-1
1 0 j=w
이 되어야함.

다만 이 경우는 정답을 내는대는 지장은 없긴함. ->왜?

그러나, 동일한 상황에서 tree_pos가 2일때, (즉 i=1인순간 tree_pos가 2일때)
[초기위치는 1로 정해져있음]
i=1 테이블은 아래와 같이됨.
0 0 j=1
0 0 j=2
~~  ~
1 0 j=w-1
0 1 j=w

?????
근데 지금보니까, 그냥 i=1일때, tp가 2이면 증가하면안되는데(자두의 초기위치가 1이라)
< -> 또, 다시 보니까 i=1이여도, 2로 이동해서 자두를 먹은거면 증가해도 됨.>
그냥 증가하게 둬서 문제가 생긴것으로 추측.(자두를 먹고 이동하든지, 먹으려고 이동하는지는 크게 중요하지않은듯? 어짜피 다 계산에반영되어서)

근데, 그래서 tree_pos가 2일 때, if(i!=1) 일때만, 이전위치가 2일때 자두를 먹는 것으로 설정함.
(즉, 맨처음에는 이전위치가 2여도 자두를 먹지 못한다.)
-> 하지만이렇게하면 문제는, 맨처음에 2로 이동해서 자두를 먹는 케이스를 부정하게 되어서
1 1
2

같은 것에서 1이 나와야 하는데 0이 나와버림. ->실제 백준테스트에서도 19퍼센트까지만 맞고 틀림

->그럼?
=>그냥, 전반적으로 점화식의 문제라고 판단되어
자두를 먹고 이동 이 아니라
자루를 먹으려고 이동으로 바꿈.

    for(int i=1; i<=t; i++){ //자두를 먹으려고 이동.
        cin>>tree_pos;
        for(int j=w; j>w-i && j>=0; j--){
            if(tree_pos==1){ //현재위치가 tree_pos와 일치하면 자두o
                if(j-1>=0) d[i][j-1][1]=max(d[i][j-1][1], d[i-1][j][2]+1); //이전위치 2에서 자두를 먹으려고 현재위치1로 이동했을 때.
                d[i][j][1]=max(d[i][j][1], d[i-1][j][1]+1); //이전위치 1, 현재위치1, 이동x, 자두o
                if(j-1>=0) d[i][j-1][2]=max(d[i][j-1][2] ,d[i-1][j][1]); //이전위치 1, 현재위치2, 이동 o, 자두x
                d[i][j][2]=max(d[i][j][2] ,d[i-1][j][2]); //이전위치 2, 현재위치2, 이동x, 자두x
            }
            else{ //tree_pos==2일때
                if(j-1>=0) d[i][j-1][1]=max(d[i][j-1][1] ,d[i-1][j][2]); //이전위치 2, 현재위치 1, 이동 o, 자두x
                d[i][j][1]=max(d[i][j][1] ,d[i-1][j][1]); //이전위치 1, 현재위치1, 이동 x, 자두x
                if(j-1>=0) d[i][j-1][2]=max(d[i][j-1][2] ,d[i-1][j][1]+1); //이전위치 1, 현재위치2, 이동o, 자두o
                d[i][j][2]=max(d[i][j][2] ,d[i-1][j][2]+1); //이전위치 2, 현재위치2, 이동x, 자두o
            }//j>=0, if(j-1>=0), max추가
        }
    }

///
위와 같이 바꿈.
그러나 여전히
3 1
2
1
1
같은 케이스에서 2가나와야 하는데 3이나옴. 여전히 첫 2를 포함한 것으로 추측

[[[!!!!!해결!!!!!]]]
if(i!=1) d[i][j][2]=max(d[i][j][2] ,d[i-1][j][2]+1); //이전위치 2, 현재위치2, 이동x, 자두o
                //i=1일땐 초기위치 2이므로 제자리에서 자두를 먹지못함. 그래서 0으로 유지해아함. 이동 한경우만 자두를 먹은것이되어야함.

tree_pos==2일때 이전위치2->현재위치2가되어 자두를 +1하는 코드에서
if(i!=1)을 위 처럼 추가하니 성공함.
[i=1일때, 자두의 초기위치는 1이므로 이동하지 않았다면 자두를 먹지 못함. +1이 되면안되기 때문.]

{tree_pos가 1일때는 어짜피 그대로 0으로 두므로 상관없음}

3. 초기값 대입
d[1][w][1]=0; //나머지도 0으로 초기화

*/