//이전 코드에서 이미 정답처리가 되었으나
//리팩토링을 위해 다시 작성한 코드
#include <iostream>
#include <algorithm>
using namespace std;

int t,w;
int d[1001][31][3]; 
//d[i][j][k]=i번째 초에서 j만큼 이동횟수가 남았고, 현재위치 k일때, 그때까지 자두를 먹은 개수

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>t>>w;
    int tree_pos; //자두가 떨어지는 나무의 위치
    d[1][w][1]=0; //자두의 초기위치는 1
    for(int i=1; i<=t; i++){ //자두를 먹으려고 이동.
        cin>>tree_pos;
        //j=w, 즉 맨처음 이동하지 않았을 때의 대한 코드 추가
        d[i][w][1]=d[i-1][w][1]+(tree_pos==1?1:0); //이동하지 않았다면 현재위치2에서는 자두 먹은횟수 증가하면 안됨.
        //즉, j=w일때 현재위치가 2라면, 이동하지 않았는데 2라는 소리이므로 논리적으로 불가능한위치임. 따라서 항상 0으로 고정됨.(i가몇이든)
        //for문에서는 w-1, 즉 최소 한번이상 이동했을때부터만 고려하고있음.
        for(int j=w-1; j>=w-i && j>=0; j--){
            if(tree_pos==1){ //현재위치가 tree_pos와 일치하면 자두o
                d[i][j][1]=max(d[i-1][j][1], d[i-1][j+1][2])+1; //1에서 가만히 있었을때, 이동했을 때 자두+1
                d[i][j][2]=max(d[i-1][j][2] ,d[i-1][j+1][1]); // 2에서 ~ 자두 x
                //어짜피 새로운 i에 대한 칸은 비어있으니까, 굳이 이전 코드처럼 4개줄을 써서 비교할필요 x, i-1일때 두 경우 중
                //max값만 취하도록 바꿔줘도 됨.
            }
            else{ //tree_pos==2일때
                d[i][j][1]=max(d[i-1][j][1] ,d[i-1][j+1][2]); //1에서 가만히 있었을때, 이동했을 때, 자두x
                d[i][j][2]=max(d[i-1][j][2] ,d[i-1][j+1][1])+1; //2에서 ~ 자두+1
            }
        }
    }

    int ans=0;
    for(int i=0; i<=w; i++) ans=max({ans, d[t][i][1], d[t][i][2]}); //t초, 현재위치 1~2일때 먹은 자두개수를 모든w에대해 비교\
    //위 코드도 정답코드 참고하여 수정함.
    //max_element로 쓸필요 없이 그냥 위치 1일때와 2일때 두개만 비교하면 되니 initial_list로 위와같이 주면됨.
    cout<<ans; 
}

/*
정답코드를 참고하여 수정 
[1] max로 묶는방식을 4줄에서 2줄로,
    ㄴ->그렇게 남은 총 4줄의 코드가(tp==1 and tp==2일때) 모두 if(j=1>=0)이어야 한다는 조건[j-1에서 out of bound방지]이 겹치므로 
        그냥, if(j-1>=0)문을 지우고 정답코드를 참고하여
        if(j-<0) break; 를 추가하는 걸로 간단히 변경함.
        ㄴ-> 근데 이렇게하면 j=0일때는 고려하지 못함.
            ㄴ-> 결국 j==0일때를 위해 다시 if(j=1>=0) 블록에 2줄 블록들을 넣고, d[i][j][1]= ~~, d[i][j][2]= ~~ 같은 코드를 2줄 추가해야됨.
                ㄴ-!!-> 저렇게 하지말고!, 
                    아래의 이 코드를
                    //수정 전 코드
                    for(int j=w; j>w-i && j>=0; j--){
                        if(tree_pos==1){ //현재위치가 tree_pos와 일치하면 자두o
                            if(j-1>=0){//out of bound 방지
                                d[i][j-1][1]=max(d[i-1][j-1][1], d[i-1][j][2])+1; //1에서 가만히 있었을때, 이동했을 때 자두+1
                                d[i][j-1][2]=max(d[i-1][j-1][2] ,d[i-1][j][1]); // 2에서 ~ 자두 x
                                //어짜피 새로운 i에 대한 칸은 비어있으니까, 굳이 이전 코드처럼 4개줄을 써서 비교할필요 x, i-1일때 두 경우 중
                                //max값만 취하도록 바꿔줘도 됨.
                            }
                        }
                        else{ //tree_pos==2일때
                            if(j-1>=0){//out of bound 방지
                                d[i][j-1][1]=max(d[i-1][j-1][1] ,d[i-1][j][2]); //1에서 가만히 있었을때, 이동했을 때, 자두x
                                d[i][j-1][2]=max(d[i-1][j-1][2] ,d[i-1][j][1])+1; //2에서 ~ 자두+1
                            }
                        }//j>=0, if(j-1>=0), max추가
                    }
                    //////////
                    아래와 같이 바꿈.
                    => 1)for문에서 j=w를 j=w-1로 바꾸고 (j=w일때는 이미 위에서 계산하고있으니까.)
                       2) [j-1] <- max[j-1][j]형태를
                           [j] <- max[j][j+1]로 바꿈,의미는 동일하고 선택지만 바뀐거
                       3)이러면, j==0일때까지만 탐색하면 되고, 이조건은 이미 for문에 j>=0 으로 존재하므로
                         if(j-1>=0) 조건문 혹은 if(j-1<0) break같은 조건문은 지움.
                       4)또한, (2)에서 말했던 것처럼 j 식이 바뀌었으므로
                        for문 조건에서 j>w-i를 j>=w=i로 변경
                 
[2] 반복할때, max함수 안에서 +1을 계산하는게 아니라, max함수 밖에서 +1을 해줌.

[3] j=w 일때, 즉 이동하지 않았을 때를 적용하는 코드는 정답코드를 참고하여 i에대한 for문 바로 아래로 빼서 작성.
    ㄴ그러므로, if(i!=1) d[i][j][2]=max(d[i][j][2] ,d[i-1][j][2]+1);과 같이 하지않아도
      맨처음에 2로 이동하지 않았을때 자두가+1되는걸 막을 수있음.

[4] ans구할 때
    max_element로 쓸필요 없이 그냥 위치 1일때와 2일때 두개만 비교하면 되니 initial_list로 위와같이 주면됨.
*/ 

/* 리팩토링 하며 깨달은점(교훈) [정답코드 보면서]

[1] 인자수가 적으면 max_element대신 그냥 max함수에 initial_list로 주면된다.
[2] 맨처음 조건(j=w) 같은 경우 억지로 for문안에 끼워 놓기 보다, 그 위의 반복문 등에 빼두는게 작성하기 편하다.
    -> 만약 j=w 조건을 j반복문 안에 넣었다면, 그걸 처리하기 위해 더 복잡해짐(직접 푼 코드 처럼)
[3] 반복문의 반복수는 그냥 j=1부터 올리는게 제일편하다. 괜히 j-- 해서 0에 도달하게 되면
    0처리도 힘들고 -1로 갔을때를대비한 out of index처리도 굉장히 복잡해진다.
[4] dp에서 max함수 쓸 때 괜히 안에서 +a 하는 것 보다, max로 공통처리 가능한거 넣고 그다음 max밖에서 +a 하는 구조로 만드는게 best다.
[5] ?


*/


/* 정답코드(별해)의 방식

- 자두가 움직인 횟수가 홀수일 경우 2번 나무, 짝수일 경우 1번 나무에 가게 됨을 이용
      d[i][j] = max(d[i - 1][j - 1], d[i - 1][j]) + (1 + j % 2 == a[i]);
해당 점화식을 채우도록 함.
이동횟수가 j가 될때 짝,홀여부 파악 후 자두먹은횟수를 +1할지, 0(false)할지 결정함.
i-1초에서 i초가 될때.
j가 되는 경우는 j-1에서 j로 변경된경우(즉, 이동을 한경우) 혹은 j에서 그대로 j로 있는 경우 둘 뿐임(이동을 안 한 경우).

이런식으로 점화식을 모두 채움.(즉, dp인데, 수학적인 관찰을 사용해서 풀 수 있다.)
->시간복잡도나 공간복잡도 면에서 
(원래 정답코드는 해당 시간, 이동횟수, 자두의 현재위치를 모두 저장하였음. 
그런데 지금 별해의 코드는 현재위치 저장이 생략되었으므로 딱, t*w만큼 더 시간, 공간면에서 절약되었음.
근데 o(N)과 같은 빅오 노테이션에서 봤을 때는 큰 차이 없음.(그래봐야 n배차이이므로)

*/