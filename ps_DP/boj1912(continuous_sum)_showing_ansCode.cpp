//정답코드 봄.
#include <iostream>
using namespace std;

int arr[100001];

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin>>n;
    for(int i=0; i<n; i++){
        cin>>arr[i];
    }
    int cur_sum=arr[0];
    int max_sum=arr[0];
    for(int i=1; i<n; i++){
        cur_sum=max(cur_sum+arr[i], arr[i]);
        max_sum=max(max_sum, cur_sum);
    }
    cout<<max_sum;
}

/*문제 바꿔보기
=> 1) 주어진 수열에서 (연속적일필요없고) 그냥 n개 골라서 최대값 구하기 
    ->그냥 수열 받은다음 최대값으로 정렬하고 앞에서 n개만큼 더해주면 끝임
=> 2) 주어진 수열에서 수를 제한없이 골라서 만들 수 있는 최대 값 구하기
    -> 그냥 차례로 수받아가면서 음수빼고, 양수만 계속 sum으로 더해나가면됨.

즉, 본래 문제같은 케이스가 아니라면 dp로 풀필요 없는 유형이 됨.
*/


//1시간정도 고민후 안풀려서 정답코드 확인.
//(사실 문제를 보자마자 투포인터, 슬라이딩 윈도우 알고리즘이 떠올랐으나 아니었음.(이건, 긴수열에서 해당하는 부분수열을 찾는데 쓰였던??것같음.))


//풀이법 ->카데인 알고리즘(Kadane's Algorithm) [카데고리컬 최대 부분합 문제에서 주로 사용]
/*
우선 첫번째 숫자를 시작점으로 하고
더해나가면서 현재까지의 부분합을 저장함.
만약 현재의 숫자를 합한 부분합이 현재 숫자보다 더 작으면
시작점을 현재 숫자로 초기화하고,
다시 부분합을 계산함.
최대합은 계속 갱신함.
*/

/*
정답코드도 비슷함.
int d[100010];

i번째 항으로 끝나는 연속합 중 최대를 저장하는 배열 d[i]테이블을 전역에서 선언하고

  for(int i = 1; i <= n; ++i)
    d[i] = max(0, d[i-1]) + a[i];
  cout << *max_element(d + 1, d + n + 1);

for문에서
현재 값을 더한 연속합이, 현재 값 보다 작아진다는건 = 현재값 이전의 연속합이 음수라는 말과 동일
따라서, max(0, d[i-1])을 통해, 이전의 값이 0보다작은지(음수인지) 체크해서 
0보다 크면 계속 d[i-1]을 (현재값)a[i]에 더하고
0보다 작으면 다시 현재값부터 더해나가도록 0을 더하도록함.

출력은 d[]테이블 중 가장 큰 값을 리턴.

*/