//정답코드는 2차원배열 하나를사용했음.
//근데 이거빼고는 그냥 별차이없음. 그냥 직접푼코드처럼 배열 두개써도될듯.

//단, k가 0과1로 한정되지 않고 여러개면 내가 직접푼코드처럼하면 복잡해지니
//확장성을 생각해서,정답코드의 방식, 특히 오랜만에 보게된 2차원배열을 잘 기억하자
        //2차원배열의 앞칸을 쓰고, 뒷칸을 종류를 구별하는 방식// -> 2차원배열은 1차원배열에 1차원배열이 들어있는 것이므로.
#include <iostream>
using namespace std;

int f[41][2]; //f[i][k], i를 fib함수에 전달 했을 때 출력되는 k의 개수

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin>>t;
    //입력으로 받는 n의 범위가 0~40이므로, 우선 40까지 테이블을 모두 채운후에 나중에 출력함.
    f[0][0]=1;
    f[1][0]=0;
    f[0][1]=0;
    f[1][1]=1;
    for(int i=2; i<=40; i++){
        f[i][0]=f[i-1][0]+f[i-2][0];
        f[i][1]=f[i-1][1]+f[i-2][1];
    }
    while(t--){
        int n;
        cin>>n;
        cout<<f[n][0]<<' '<<f[n][1]<<'\n';
    }

}

/*만약 테스트케이스(지시문) 마다 테이블 채우기를 반복했다면? -> t(테스트케이스횟수)*40번을 반복했을 것. t는 제한조건이 없으므로 무한정커지면 
시간제약을 넘었을 것.
dp는 어지간하면 o(n)이므로 그냥 처음부터 테이블 다 채워도 500만정도 넘기는거 아니면 시간안에 다 채움. 그니까 그냥 초반에 다채우자.

/*정답코드는 f0, f1배열을 두지않고,2차원배열 한개 씀, f[i][k]로 두어서, k를 0과1로 한정함.
->ans코드 확인*/

/*
1. 테이블 정의
f[i][k]=i를 fib함수에 인자로 전달 했을 때 k가 출력되는 횟수

2. 점화식 찾기
f0[i]=f0[i-1]+f0[i-2];
f1[i]=f1[i-1]+f0[i-2];

3. 초기값 대입
f0[0]=1;
f0[1]=0;

f1[0]=0;
f1[1]=1;
*/
