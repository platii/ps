#include <iostream>
#include <algorithm>
using namespace std;

int n;
int d[1001][10];
int mod=10007;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    fill(d[1], d[1]+10, 1);
    for(int i=1; i<=n; i++){
        for(int j=0; j<10; j++){
            /*  [정답코드 확인함]
                d[i][j]=(d[i-1][j]+d[i][j-1])%mod; 
                이거 하나로 k-for문, d[i][j]%=mod 대체 가능.
                ->d[i-1][0]~d[i-1][j-1]은 이미 d[i][j-1]에 저장되어있고, 
                d[i-1][j]만 더해주면 되기 때문임!!! 이걸통해 시간복잡도 10배 줄일 수 있음.
            */
            for(int k=0; k<=j; k++){
                d[i][j]+=d[i-1][k];
            }
            d[i][j]%=mod;
        }
    }
    int ans=0;
    for(int i=0; i<10; i++){
        ans+=d[n][i];
    }
    ans%=mod;
    cout<<ans;
}

//mod의 덧셈 법칙 : (a+b) mod x = (a mod x + b mod x) mod x

/* [풀이]
풀이는 그냥 코드 그대로 읽으면 됨.

각 인덱스에서, 해당 값이 예를들어 5이면, 바로 앞에 0,1,2,3,4,5 까지 와도 됨.
그럼 i-1인덱스에서 0~5까지인, d[i-1][0~5]를 모두 더해주면 됨.
[그인덱스가 5일때, 5바로 앞자리에 0인 경우, 5앞자리에 1인경우, ... 5인 경우를 모두 더한 것이 해당 경우의 수 전부이기 때문.]


//->오히려 mod법칙에서 실수함.
이런류 문제 풀때는, mod법칙 한번 상기한 후에 다시 풀것. 실수 조심.
여기선 d[i][j]+=d[i-1][k]%mod; 로하면
알아서 mod반영될 것이라 생각했는데
잘생각해보면 다 더한 후에 마지막에 %mod를 해줬어야함. 이걸안해준 실수.
그리고, 이미 이전칸들이 모두 %mod가 되어있는 값들이니
다 합한 후에 본문 코드처럼 k=0~k=j까지 다 더한 후에 마지막에 %mod해주면됨.

*/

/* [정답코드 확인함]

    [코드 개선]

    k, for문 부분을 없애고 
    j, for문 안에서
                
    d[i][j]=(d[i-1][j]+d[i][j-1])%mod; 
    이거 하나로 대체 가능.
    ->d[i-1][0]~d[i-1][j-1]은 이미 d[i][j-1]에 저장되어있고, 
    d[i-1][j]만 더해주면 되기 때문임!!! 이걸통해 시간복잡도 10배 줄일 수 있음.
    

    + [accumulate함수]
    
    프로그래밍 언어 할때 배웠던 그 함수랑 비슷함.
    ///////////////////////////////////////////////////// (기본 신택스)
    #include <numeric>  // accumulate 함수가 포함된 헤더

    T accumulate(InputIterator first, InputIterator last, T init);
    /////////////////////////////////////////////////////

    (사용 예)
    int sum = accumulate(arr, arr + 5, 10);  // 초기값 10 추가
    cout << sum;  // 출력: 25 (10 + 1 + 2 + 3 + 4 + 5)

    -> 앞의 초기값 부터, 인자로 전달한 배열의 첫번째(first)부터 마지막까지(last) 더하는 함수.

    numeric헤더가 필요함을 다시한번 기억하기.


    [정답코드 별해]
    ->조합을 사용하여 푸는 방법이 있음. -> 0x12수학 챕터 참고.
*/