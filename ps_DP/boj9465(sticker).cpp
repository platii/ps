#include <iostream>
#include <algorithm>
using namespace std;

int t,n;
int a[200001][2];
int d[200001][3]; //d[i][j]=i번째 인덱스까지, i번째열에서 위쪽스티커를 뗏을때(j=0), 아럐쪽(j=1), 둘다안뗏을때(j=2) 점수의 최대값

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=0; i<=1; i++) //a배열 입력받기.
            for(int j=1; j<=n; j++) cin>>a[j][i];

        //d배열의 초기값은 0
        
        //d배열 채우기
        for(int i=1; i<=n; i++){
            d[i][0]=max(d[i-1][1], d[i-1][2])+a[i][0];
            d[i][1]=max(d[i-1][0], d[i-1][2])+a[i][1];
            d[i][2]=max(d[i-1][0], d[i-1][1]); //정정 d[i-1][2]는 비교할필요없음 ->why? 무조건 앞에있던걸 하나라도 뗀게 더 크기때문.
            
        }
        cout<<*max_element(d[n], d[n]+3)<<'\n';
    }
}

/*
정답코드의 방식(근데 그냥 직접푼 코드 방식이 더 간결하고 좋은듯.)
- 배열대신 벡터를 사용하였음.
- 내코드와 비슷하게, 위를 뗀경우, 아레를 뗀경우로 분리하였으나/ 전부 뗀경우는 고려하진 않음.(내 코드처럼 따로 2로 설정해두진않았다는 말)
- 전전칸에서의 위, 아래 중 하나를 뗀경우와 전칸에서 현재 떼는 행이 아닌 다른 행을 뗐을 때 2가지 케이스를 비교했음.
    ㄴ이렇게하면, 이전칸과 현재i칸이 간섭이 있는 경우, 이전칸과 현재i칸 간섭없이(즉 이전칸은 선택없이, i-2번째 칸만 채운경우)하는 경우 
        두가지를 커버가능.
- 이후 현재 인덱스의 해당 행을 더해줌.
- 번외) 벡터 선언문 
  => std::vector<DataType> 벡터이름<size, initialValue>;
    ex) std::vector<int> vec(5, 0); // 크기 5, 초기값 0 -> 5칸 모두 0으로 초기화 됨.
  => 굳이 벡터를 쓰는 이유?
   -> main함수 내에서 
      cin>>n;
      int a[n][3]; 
      처럼 쓰는건 표준 c++에서는 원래 안되는 거임.
      vla(가변길이배열)를 지원하는 경우만 되는 거임.
      따라서 이식성이 좋도록(호환성이 좋도록)하려면 n이 정해지고 나서 배열을 만들려면 벡터를 쓰는 것이 좋음.
      (사실 이 코드의 경우 메모리문제는 없었지만 만약 n의 최대값이 더 크고, 실제 동작은 그보다 훨씬 작은 범위에서 
      이뤄진다면 벡터를 쓰는게 효율적임.)

아래는 정답코드임.
vector<vector<int>> arr(N, vector<int>(2)), dp(N, vector<int>(2)); // N by 2 vector를 선언
    for (int j = 0; j < 2; j++)
      for (int i = 0; i < N; i++)
        cin >> arr[i][j];
    
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < 2; j++) {
        int v = 0;
        if (i > 1) v = max(dp[i - 2][0], dp[i - 2][1]);
        if (i > 0) v = max(v, dp[i - 1][1 - j]);
        dp[i][j] = v + arr[i][j];
      }
    }
    cout << max(dp[N - 1][0], dp[N - 1][1]) << '\n';
  } 
}

//
dp[i][j] : i번째 열까지에서 점수의 최댓값, 단 j행 i열의 스티커는 반드시 선택

가장 직전에 붙인 스티커가 i-2열의 스티커인 경우 : max(dp[i - 2][0], dp[i - 2][1]) + arr[i][j]
가장 직전에 붙인 스티커가 i-1열의 스티커인 경우 : dp[i-1][1-j] + arr[i][j]

마지막 열에 있는 스티커 중 어느 하나는 반드시 붙인게 최댓값이므로 max(dp[N - 1][0], dp[N - 1][1])을 계산하면 됨
//

*/




//////////////////////
/* 안봐도 됨. 그냥 기록.
시도하다가 만 방식(더 간단한 방법(본문의 코드)을 찾았고, 사실 풀 방법이 딱히 안떠올라서 시도안함.)


//int d[200001][2][2]; //d[i][j]=i번째인덱스까지, i번째 열, j번째 행을 선택했을 때/안했을 때(0=선택 x, 1=선택 o) 점수의 최대값.


            //우선보류, 본문 코드 처럼 변경
            d[i][0][0]=max({d[i-1][0][0], });
            d[i][0][1]=max(d[i-1][], );
            d[i][1][0]=max(d[i-1][]);
            d[i][1][1]=max(d[i-1][]);
            

*/